
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">scaffold/server/api/auth.go (35.7%)</option>
				
				<option value="file1">scaffold/server/api/cascade.go (67.3%)</option>
				
				<option value="file2">scaffold/server/api/container.go (0.0%)</option>
				
				<option value="file3">scaffold/server/api/datastore.go (33.9%)</option>
				
				<option value="file4">scaffold/server/api/health.go (25.0%)</option>
				
				<option value="file5">scaffold/server/api/helpers.go (70.0%)</option>
				
				<option value="file6">scaffold/server/api/input.go (60.8%)</option>
				
				<option value="file7">scaffold/server/api/run.go (22.8%)</option>
				
				<option value="file8">scaffold/server/api/state.go (65.7%)</option>
				
				<option value="file9">scaffold/server/api/task.go (65.7%)</option>
				
				<option value="file10">scaffold/server/api/user.go (8.9%)</option>
				
				<option value="file11">scaffold/server/auth/auth.go (6.1%)</option>
				
				<option value="file12">scaffold/server/cascade/cascade.go (75.5%)</option>
				
				<option value="file13">scaffold/server/cmd/cmd.go (9.9%)</option>
				
				<option value="file14">scaffold/server/config/config.go (67.4%)</option>
				
				<option value="file15">scaffold/server/container/container.go (33.3%)</option>
				
				<option value="file16">scaffold/server/datastore/datastore.go (82.3%)</option>
				
				<option value="file17">scaffold/server/docs/docs.go (100.0%)</option>
				
				<option value="file18">scaffold/server/filestore/filestore.go (32.0%)</option>
				
				<option value="file19">scaffold/server/input/input.go (80.6%)</option>
				
				<option value="file20">scaffold/server/logger/logger.go (35.4%)</option>
				
				<option value="file21">scaffold/server/main.go (75.0%)</option>
				
				<option value="file22">scaffold/server/manager/manager.go (32.8%)</option>
				
				<option value="file23">scaffold/server/middleware/middleware.auth.go (40.9%)</option>
				
				<option value="file24">scaffold/server/middleware/middleware.cors.go (77.8%)</option>
				
				<option value="file25">scaffold/server/mongodb/mongodb.go (80.0%)</option>
				
				<option value="file26">scaffold/server/page/page.go (0.0%)</option>
				
				<option value="file27">scaffold/server/proxy/proxy.go (0.0%)</option>
				
				<option value="file28">scaffold/server/routes.go (100.0%)</option>
				
				<option value="file29">scaffold/server/run/run.go (0.0%)</option>
				
				<option value="file30">scaffold/server/state/state.go (80.6%)</option>
				
				<option value="file31">scaffold/server/task/task.go (79.1%)</option>
				
				<option value="file32">scaffold/server/user/user.go (57.5%)</option>
				
				<option value="file33">scaffold/server/utils/utils.go (39.5%)</option>
				
				<option value="file34">scaffold/server/worker/worker.go (50.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package api

import (
        "net/http"
        "scaffold/server/user"
        "scaffold/server/utils"

        "github.com/gin-gonic/gin"
)

//        @summary                                        Generate API Token
//        @description                                Generate an API token for a user
//        @tags                                                manager
//        @tags                                                user
//        @produce                                        json
//        @success                                        200        {array}                object
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /auth/token/{username}/{token_name} [post]
func GenerateAPIToken(ctx *gin.Context) <span class="cov10" title="5">{
        username := ctx.Param("username")
        name := ctx.Param("name")

        token, err := user.GenerateAPIToken(username, name)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov10" title="5">ctx.JSON(http.StatusCreated, gin.H{"token": token})</span>
}

//        @summary                                        Revoke API Token
//        @description                                Revoke an API token for a user
//        @tags                                                manager
//        @tags                                                user
//        @produce                                        json
//        @success                                        200        {array}                object
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /auth/token/{username}/{token_name} [delete]
func RevokeAPIToken(ctx *gin.Context) <span class="cov0" title="0">{
        username := ctx.Param("username")
        name := ctx.Param("name")

        err := user.RevokeAPIToken(username, name)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{"message": "OK"})</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package api

import (
        "errors"
        "net/http"
        "scaffold/server/cascade"
        "scaffold/server/utils"

        "github.com/gin-gonic/gin"
        "go.mongodb.org/mongo-driver/mongo"
)

//        @summary                                        Create a cascade
//        @description                                Create a cascade from a JSON object
//        @tags                                                manager
//        @tags                                                cascade
//        @accept                                                json
//        @produce                                        json
//        @Param                                                cascade        body                cascade.Cascade        true        "Cascade Data"
//        @success                                        201                {object}        object
//        @failure                                        500                {object}        object
//        @failure                                        401                {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/cascade [post]
func CreateCascade(ctx *gin.Context) <span class="cov6" title="5">{
        var c cascade.Cascade
        if err := ctx.ShouldBindJSON(&amp;c); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov6" title="5">if c.Groups != nil </span><span class="cov5" title="4">{
                if !validateUserGroup(ctx, c.Groups) </span><span class="cov0" title="0">{
                        utils.Error(errors.New("user is not part of required groups to access this resources"), ctx, http.StatusUnauthorized)
                }</span>
        }

        <span class="cov6" title="5">err := cascade.CreateCascade(&amp;c)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov6" title="5">ctx.JSON(http.StatusCreated, gin.H{"message": "Created"})</span>
}

//        @summary                                        Delete a cascade
//        @description                                Delete a cascade by its name
//        @tags                                                manager
//        @tags                                                cascade
//        @produce                                        json
//        @success                                        200        {object}        object
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/cascade/{cascade_name} [delete]
func DeleteCascadeByName(ctx *gin.Context) <span class="cov1" title="1">{
        name := ctx.Param("name")

        err := cascade.DeleteCascadeByName(name)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">ctx.JSON(http.StatusOK, gin.H{"message": "OK"})</span>
}

//        @summary                                        Get all cascades
//        @description                                Get all cascades
//        @tags                                                manager
//        @tags                                                cascade
//        @produce                                        json
//        @success                                        200        {array}                cascade.Cascade
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/cascade [get]
func GetAllCascades(ctx *gin.Context) <span class="cov6" title="6">{
        cascades, err := cascade.GetAllCascades()

        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        ctx.JSON(http.StatusNoContent, []interface{}{})
                        return
                }</span>
                <span class="cov0" title="0">utils.Error(err, ctx, http.StatusInternalServerError)
                return</span>
        }

        // Need to copy each cascade from pointer to value since pointers are returned
        // weirdly (I think at least)
        <span class="cov6" title="6">cascadesOut := make([]cascade.Cascade, 0)
        for _, c := range cascades </span><span class="cov10" title="18">{
                if c.Groups != nil </span><span class="cov8" title="12">{
                        if validateUserGroup(ctx, c.Groups) </span><span class="cov7" title="7">{
                                cascadesOut = append(cascadesOut, *c)
                        }</span>
                        <span class="cov8" title="12">continue</span>
                }
                <span class="cov6" title="6">cascadesOut = append(cascadesOut, *c)</span>
        }

        <span class="cov6" title="6">ctx.JSON(http.StatusOK, cascadesOut)</span>
}

//        @summary                                        Get a cascade
//        @description                                Get a cascade by its name
//        @tags                                                manager
//        @tags                                                cascade
//        @produce                                        json
//        @success                                        200        {object}        cascade.Cascade
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/cascade/{cascade_name} [get]
func GetCascadeByName(ctx *gin.Context) <span class="cov9" title="15">{
        name := ctx.Param("name")

        c, err := cascade.GetCascadeByName(name)

        if err != nil </span><span class="cov4" title="3">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="12">ctx.JSON(http.StatusOK, *c)</span>
}

//        @summary                                        Update a cascade
//        @description                                Update a cascade from a JSON object
//        @tags                                                manager
//        @tags                                                cascade
//        @accept                                                json
//        @produce                                        json
//        @Param                                                cascade        body                cascade.Cascade        true        "Cascade Data"
//        @success                                        201                {object}        object
//        @failure                                        500                {object}        object
//        @failure                                        401                {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/cascade/{cascade_name} [put]
func UpdateCascadeByName(ctx *gin.Context) <span class="cov1" title="1">{
        name := ctx.Param("name")

        var c cascade.Cascade
        if err := ctx.ShouldBindJSON(&amp;c); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">err := cascade.UpdateCascadeByName(name, &amp;c)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">ctx.JSON(http.StatusOK, gin.H{"message": "OK"})</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package api

import (
        "encoding/json"
        "fmt"
        "io/ioutil"
        "net/http"
        "scaffold/server/auth"
        "scaffold/server/container"
        "scaffold/server/logger"

        "github.com/gin-gonic/gin"
)

//        @summary                                        Get available containers
//        @description                                List containers available for execution
//        @tags                                                worker
//        @produce                                        json
//        @success                                        200        {array}                string
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/available [get]
func GetAvailableContainers(ctx *gin.Context) <span class="cov0" title="0">{
        output := []string{}

        for idx, groups := range container.LastGroups </span><span class="cov0" title="0">{
                if validateUserGroup(ctx, groups) </span><span class="cov0" title="0">{
                        output = append(output, container.LastRun[idx])
                }</span>
        }

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, container.LastRun)</span>
}

func GetAllContainers(ctx *gin.Context) <span class="cov0" title="0">{
        available := map[string][]string{}
        for _, n := range auth.Nodes </span><span class="cov0" title="0">{
                httpClient := http.Client{}
                requestURL := fmt.Sprintf("%s://%s:%d/api/v1/available", n.Protocol, n.Host, n.Port)
                req, _ := http.NewRequest("GET", requestURL, nil)
                req.Header.Set("Authorization", ctx.Request.Header.Get("X-Scaffold-API"))
                req.Header.Set("Content-Type", "application/json")
                resp, err := httpClient.Do(req)

                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("", "Error getting available containers %s", err.Error())
                        continue</span>
                }
                <span class="cov0" title="0">if resp.StatusCode == http.StatusOK </span><span class="cov0" title="0">{
                        //Read the response body
                        body, err := ioutil.ReadAll(resp.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Errorf("", "Error reading body: %s", err.Error())
                                continue</span>
                        }
                        <span class="cov0" title="0">var data []string
                        json.Unmarshal(body, &amp;data)

                        if len(data) &gt; 0 </span><span class="cov0" title="0">{
                                available[fmt.Sprintf("%s:%d", n.Host, n.WSPort)] = data
                        }</span>
                        <span class="cov0" title="0">resp.Body.Close()</span>
                }
        }
        <span class="cov0" title="0">ctx.JSON(http.StatusOK, available)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package api

import (
        "errors"
        "fmt"
        "net/http"
        "os"
        "scaffold/server/cascade"
        "scaffold/server/config"
        "scaffold/server/constants"
        "scaffold/server/datastore"
        "scaffold/server/filestore"
        "scaffold/server/input"
        "scaffold/server/utils"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "go.mongodb.org/mongo-driver/mongo"
)

//        @summary                                        Create a datastore
//        @description                                Create a datastore from a JSON object
//        @tags                                                manager
//        @tags                                                datastore
//        @accept                                                json
//        @produce                                        json
//        @Param                                                datastore        body                datastore.DataStore        true        "DataStore Data"
//        @success                                        201                        {object}        object
//        @failure                                        500                        {object}        object
//        @failure                                        401                        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/datastore [post]
func CreateDataStore(ctx *gin.Context) <span class="cov1" title="1">{
        var d datastore.DataStore
        if err := ctx.ShouldBindJSON(&amp;d); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">c, err := cascade.GetCascadeByName(d.Name)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusNotFound)
        }</span>
        <span class="cov1" title="1">if c.Groups != nil </span><span class="cov1" title="1">{
                if !validateUserGroup(ctx, c.Groups) </span><span class="cov0" title="0">{
                        utils.Error(errors.New("user is not part of required groups to access this resources"), ctx, http.StatusUnauthorized)
                }</span>
        }

        <span class="cov1" title="1">err = datastore.CreateDataStore(&amp;d)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">ctx.JSON(http.StatusCreated, gin.H{"message": "Created"})</span>
}

//        @summary                                        Delete a datastore
//        @description                                Delete a datastore by its name
//        @tags                                                manager
//        @tags                                                datastore
//        @produce                                        json
//        @success                                        200        {object}        object
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/datastore/{datastore_name} [delete]
func DeleteDataStoreByCascade(ctx *gin.Context) <span class="cov1" title="1">{
        name := ctx.Param("name")

        err := datastore.DeleteDataStoreByCascade(name)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">ctx.JSON(http.StatusOK, gin.H{"message": "OK"})</span>
}

//        @summary                                        Get all datastores
//        @description                                Get all datastores
//        @tags                                                manager
//        @tags                                                datastore
//        @produce                                        json
//        @success                                        200        {array}                datastore.DataStore
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/datastore [get]
func GetAllDataStores(ctx *gin.Context) <span class="cov6" title="6">{
        datastores, err := datastore.GetAllDataStores()

        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        ctx.JSON(http.StatusNoContent, []interface{}{})
                        return
                }</span>
                <span class="cov0" title="0">utils.Error(err, ctx, http.StatusInternalServerError)
                return</span>
        }

        // Need to copy each cascade from pointer to value since pointers are returned
        // weirdly (I think at least)
        <span class="cov6" title="6">datastoresOut := make([]datastore.DataStore, 0)
        for _, d := range datastores </span><span class="cov10" title="18">{
                c, err := cascade.GetCascadeByName(d.Name)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov10" title="18">if c.Groups != nil </span><span class="cov8" title="12">{
                        if validateUserGroup(ctx, c.Groups) </span><span class="cov7" title="7">{
                                datastoresOut = append(datastoresOut, *d)
                        }</span>
                        <span class="cov8" title="12">continue</span>
                }
                <span class="cov6" title="6">datastoresOut = append(datastoresOut, *d)</span>
        }

        <span class="cov6" title="6">ctx.JSON(http.StatusOK, datastoresOut)</span>
}

//        @summary                                        Get a datastore
//        @description                                Get a datastore by its name
//        @tags                                                manager
//        @tags                                                datastore
//        @produce                                        json
//        @success                                        200        {object}        datastore.DataStore
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/datastore/{datastore_name} [get]
func GetDataStoreByCascade(ctx *gin.Context) <span class="cov8" title="12">{
        name := ctx.Param("name")

        d, err := datastore.GetDataStoreByCascade(name)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="12">ctx.JSON(http.StatusOK, *d)</span>
}

//        @summary                                        Update a datastore
//        @description                                Update a datastore from a JSON object
//        @tags                                                manager
//        @tags                                                datastore
//        @accept                                                json
//        @produce                                        json
//        @Param                                                datastore        body                datastore.DataStore        true        "DataStore Data"
//        @success                                        201                        {object}        object
//        @failure                                        500                        {object}        object
//        @failure                                        401                        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/datastore/{datastore_name} [put]
func UpdateDataStoreByCascade(ctx *gin.Context) <span class="cov3" title="2">{
        name := ctx.Param("name")

        var d datastore.DataStore
        if err := ctx.ShouldBindJSON(&amp;d); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        // Need to copy over cascade inputs since some weirdness happens when updating the
        // datastore
        <span class="cov3" title="2">inputs := []input.Input{}
        if config.Config.Node.Type == constants.NODE_TYPE_MANAGER </span><span class="cov3" title="2">{
                c, err := cascade.GetCascadeByName(name)
                if err != nil </span><span class="cov0" title="0">{
                        utils.Error(err, ctx, http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov3" title="2">inputs = c.Inputs</span>
        }

        <span class="cov3" title="2">err := datastore.UpdateDataStoreByCascade(name, &amp;d, inputs)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov3" title="2">ctx.JSON(http.StatusOK, gin.H{"message": "OK"})</span>
}

//        @summary                                        Download a file
//        @description                                Download a file from a datastore
//        @tags                                                manager
//        @tags                                                datastore
//        @tags                                                file
//        @produce                                        application/text/plain
//        @success                                        200
//        @failure                                        500
//        @failure                                        401
//        @failure                                        404
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/file/{datastore_name}/{file_name} [get]
func DownloadFile(ctx *gin.Context) <span class="cov0" title="0">{
        name := ctx.Param("name")
        fileName := ctx.Param("file")

        c, err := cascade.GetCascadeByName(name)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusNotFound)
        }</span>
        <span class="cov0" title="0">if c.Groups != nil </span><span class="cov0" title="0">{
                if !validateUserGroup(ctx, c.Groups) </span><span class="cov0" title="0">{
                        utils.Error(errors.New("user is not part of required groups to access this resources"), ctx, http.StatusUnauthorized)
                }</span>
        }

        <span class="cov0" title="0">path := fmt.Sprintf("/tmp/%s", uuid.New().String())

        err = filestore.GetFile(fmt.Sprintf("%s/%s", name, fileName), path)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">ctx.Header("Content-Disposition", "attachment; filename="+fileName)
        ctx.Header("Content-Type", "application/text/plain")
        ctx.Header("Accept-Length", fmt.Sprintf("%d", len(data)))
        ctx.Writer.Write([]byte(data))
        ctx.Status(http.StatusOK)

        if err := os.Remove(path); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
        }</span>
}

//        @summary                                        Upload a file
//        @description                                Upload a file to a datastore
//        @tags                                                manager
//        @tags                                                datastore
//        @tags                                                file
//        @accept                                                multipart/form-data
//        @produce                                        json
//        @success                                        200
//        @failure                                        500
//        @failure                                        400
//        @failure                                        401
//        @failure                                        404
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/file/{datastore_name} [post]
func UploadFile(ctx *gin.Context) <span class="cov0" title="0">{
        name := ctx.Param("name")

        c, err := cascade.GetCascadeByName(name)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusNotFound)
        }</span>
        <span class="cov0" title="0">if c.Groups != nil </span><span class="cov0" title="0">{
                if !validateUserGroup(ctx, c.Groups) </span><span class="cov0" title="0">{
                        utils.Error(errors.New("user is not part of required groups to access this resources"), ctx, http.StatusUnauthorized)
                }</span>
        }

        <span class="cov0" title="0">file, err := ctx.FormFile("file")
        fileName := file.Filename

        // The file cannot be received.
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">path := fmt.Sprintf("/tmp/%s", uuid.New().String())

        // The file is received, so let's save it
        if err := ctx.SaveUploadedFile(file, path); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if err := filestore.UploadFile(path, fmt.Sprintf("%s/%s", name, fileName)); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if err := os.Remove(path); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">ds, err := datastore.GetDataStoreByCascade(name)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">ds.Files = append(ds.Files, fileName)

        inputs := []input.Input{}

        if err := datastore.UpdateDataStoreByCascade(name, ds, inputs); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        // File saved successfully. Return proper result
        <span class="cov0" title="0">utils.DynamicAPIResponse(ctx, "/ui/files", http.StatusOK, gin.H{"message": "OK"})</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package api

import (
        "net/http"
        "scaffold/server/constants"
        "scaffold/server/health"

        "github.com/gin-gonic/gin"
)

//        @summary                Check if a node is healthy
//        @description        Get node health
//        @tags                        manager
//        @tags                        worker
//        @tags                        health
//        @success                200
//        @failure                503
//        @router                        /health/healthy [get]
func Healthy(c *gin.Context) <span class="cov10" title="100">{
        if health.IsHealthy </span><span class="cov10" title="100">{
                c.JSON(http.StatusOK, gin.H{"version": constants.VERSION})
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusServiceUnavailable)</span>
}

//        @summary                Check if a node is ready
//        @description        Get node readiness
//        @tags                        manager
//        @tags                        worker
//        @tags                        health
//        @success                200
//        @failure                503
//        @router                        /health/ready [get]
func Ready(c *gin.Context) <span class="cov0" title="0">{
        if health.IsReady </span><span class="cov0" title="0">{
                c.Status(http.StatusOK)
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusServiceUnavailable)</span>
}

//        @summary                Check if a worker node is available
//        @description        Get status from node succeeding if not containers are running
//        @tags                        worker
//        @tags                        health
//        @success                200
//        @failure                503
//        @router                        /health/available [get]
func Available(c *gin.Context) <span class="cov0" title="0">{
        if health.IsAvailable </span><span class="cov0" title="0">{
                c.Status(http.StatusOK)
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusServiceUnavailable)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// API implements worker and manager API endpoints for Scaffold functionality
package api

import (
        "fmt"
        "net/http"
        "strings"

        "github.com/gin-gonic/gin"

        "scaffold/server/auth"
        "scaffold/server/config"
        "scaffold/server/logger"
        "scaffold/server/user"
        "scaffold/server/utils"
)

func getAvailableNode() (*auth.NodeObject, error) <span class="cov2" title="3">{
        if len(auth.Nodes) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no nodes to schedule runs on")
        }</span>
        <span class="cov2" title="3">nodeIdx := auth.LastScheduledIdx + 1

        for idx, n := range auth.Nodes </span><span class="cov2" title="3">{
                queryURL := fmt.Sprintf("%s://%s:%d/health/available", n.Protocol, n.Host, n.Port)
                resp, err := http.Get(queryURL)
                if err != nil || resp.StatusCode &gt;= 400 </span><span class="cov2" title="3">{
                        continue</span>
                }
                <span class="cov0" title="0">nodeIdx = idx
                break</span>
        }
        <span class="cov2" title="3">if nodeIdx &gt;= len(auth.Nodes) </span><span class="cov2" title="3">{
                nodeIdx = 0
        }</span>
        <span class="cov2" title="3">auth.LastScheduledIdx = nodeIdx

        return &amp;auth.Nodes[nodeIdx], nil</span>
}

func validateUserGroup(ctx *gin.Context, groups []string) bool <span class="cov10" title="587">{
        var token string
        var err error
        var usr *user.User

        logger.Infof("", "Validating user against groups: %v", groups)

        if len(groups) == 0 </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check if we have an auth header
        <span class="cov10" title="587">authString := ctx.Request.Header.Get("Authorization")
        if authString == "" </span><span class="cov0" title="0">{
                // Check if the request is coming from a logged in UI user
                token, err = ctx.Cookie("scaffold_token")
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">usr, _ = user.GetUserByLoginToken(token)
                if usr == nil </span><span class="cov0" title="0">{
                        return false
                }</span>
        } else<span class="cov10" title="587"> {
                token = strings.Split(authString, " ")[1]
        }</span>

        // Is the request coming from a node itself?
        <span class="cov10" title="587">if token == config.Config.Node.PrimaryKey </span><span class="cov0" title="0">{
                return true
        }</span>

        // Get the user via the information
        <span class="cov10" title="587">usr, _ = user.GetUserByAPIToken(token)
        if usr == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov10" title="587">if utils.Contains(usr.Groups, "admin") </span><span class="cov8" title="178">{
                return true
        }</span>
        <span class="cov9" title="409">for _, group := range groups </span><span class="cov9" title="409">{
                if utils.Contains(usr.Groups, group) </span><span class="cov8" title="159">{
                        return true
                }</span>
        }

        <span class="cov8" title="250">return false</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package api

import (
        "errors"
        "net/http"
        "scaffold/server/cascade"
        "scaffold/server/input"
        "scaffold/server/manager"
        "scaffold/server/utils"

        "github.com/gin-gonic/gin"
        "go.mongodb.org/mongo-driver/mongo"
)

//        @summary                                        Create a input
//        @description                                Create a input from a JSON object
//        @tags                                                manager
//        @tags                                                input
//        @accept                                                json
//        @produce                                        json
//        @Param                                                input        body                input.Input        true        "Input Data"
//        @success                                        201                {object}        object
//        @failure                                        500                {object}        object
//        @failure                                        401                {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/input [post]
func CreateInput(ctx *gin.Context) <span class="cov4" title="2">{
        var i input.Input
        if err := ctx.ShouldBindJSON(&amp;i); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov4" title="2">c, err := cascade.GetCascadeByName(i.Cascade)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusNotFound)
        }</span>
        <span class="cov4" title="2">if c.Groups != nil </span><span class="cov4" title="2">{
                if !validateUserGroup(ctx, c.Groups) </span><span class="cov0" title="0">{
                        utils.Error(errors.New("user is not part of required groups to access this resources"), ctx, http.StatusUnauthorized)
                }</span>
        }

        <span class="cov4" title="2">err = input.CreateInput(&amp;i)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov4" title="2">ctx.JSON(http.StatusCreated, gin.H{"message": "Created"})</span>
}

//        @summary                                        Delete a input
//        @description                                Delete a input by its name and its cascade
//        @tags                                                manager
//        @tags                                                input
//        @produce                                        json
//        @success                                        200        {object}        object
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/input/{input_name} [delete]
func DeleteInputByNames(ctx *gin.Context) <span class="cov1" title="1">{
        cn := ctx.Param("cascade")
        n := ctx.Param("name")

        err := input.DeleteInputByNames(cn, n)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">ctx.JSON(http.StatusOK, gin.H{"message": "OK"})</span>
}

//        @summary                                        Delete inputs
//        @description                                Delete inputs by their cascade
//        @tags                                                manager
//        @tags                                                input
//        @produce                                        json
//        @success                                        200        {object}        object
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/input/{cascade_name} [delete]
func DeleteInputsByCascade(ctx *gin.Context) <span class="cov1" title="1">{
        cn := ctx.Param("cascade")

        err := input.DeleteInputsByCascade(cn)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">ctx.JSON(http.StatusOK, gin.H{"message": "OK"})</span>
}

//        @summary                                        Get all inputs
//        @description                                Get all inputs
//        @tags                                                manager
//        @tags                                                input
//        @produce                                        json
//        @success                                        200        {array}                input.Input
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/input [get]
func GetAllInputs(ctx *gin.Context) <span class="cov1" title="1">{
        inputs, err := input.GetAllInputs()

        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        ctx.JSON(http.StatusNoContent, []interface{}{})
                }</span>
                <span class="cov0" title="0">utils.Error(err, ctx, http.StatusInternalServerError)
                return</span>
        }

        <span class="cov1" title="1">inputsOut := make([]input.Input, 0)
        for _, i := range inputs </span><span class="cov10" title="7">{
                c, err := cascade.GetCascadeByName(i.Cascade)
                if err == nil </span><span class="cov10" title="7">{
                        continue</span>
                }
                <span class="cov0" title="0">if c.Groups != nil </span><span class="cov0" title="0">{
                        if validateUserGroup(ctx, c.Groups) </span><span class="cov0" title="0">{
                                inputsOut = append(inputsOut, *i)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov0" title="0">inputsOut = append(inputsOut, *i)</span>
        }

        <span class="cov1" title="1">ctx.JSON(http.StatusOK, inputsOut)</span>
}

//        @summary                                        Get a input
//        @description                                Get a input by its name and its cascade
//        @tags                                                manager
//        @tags                                                input
//        @produce                                        json
//        @success                                        200        {object}        input.Input
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/input/{cascade_name}/{input_name} [get]
func GetInputByNames(ctx *gin.Context) <span class="cov1" title="1">{
        cn := ctx.Param("cascade")
        n := ctx.Param("name")

        i, err := input.GetInputByNames(cn, n)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">ctx.JSON(http.StatusOK, *i)</span>
}

//        @summary                                        Get inputs
//        @description                                Get inputs by their cascade
//        @tags                                                manager
//        @tags                                                input
//        @produce                                        json
//        @success                                        200        {array}                input.Input
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/input/{cascade_name} [get]
func GetInputsByCascade(ctx *gin.Context) <span class="cov1" title="1">{
        cn := ctx.Param("cascade")

        i, err := input.GetInputsByCascade(cn)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">ctx.JSON(http.StatusOK, i)</span>
}

//        @summary                                        Update a input
//        @description                                Update a input from a JSON object
//        @tags                                                manager
//        @tags                                                input
//        @accept                                                json
//        @produce                                        json
//        @Param                                                input        body                input.Input        true        "Input Data"
//        @success                                        201                {object}        object
//        @failure                                        500                {object}        object
//        @failure                                        401                {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/input/{cascade_name}/{input_name} [put]
func UpdateInputByNames(ctx *gin.Context) <span class="cov1" title="1">{
        cn := ctx.Param("cascade")
        n := ctx.Param("name")

        var i input.Input
        if err := ctx.ShouldBindJSON(&amp;i); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">err := input.UpdateInputByNames(cn, n, &amp;i)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">ctx.JSON(http.StatusOK, gin.H{"message": "OK"})</span>
}

//        @summary                                        Trigger update to dependent tasks
//        @description                                Trigger updates of states for dependent tasks
//        @tags                                                manager
//        @tags                                                input
//        @produce                                        json
//        @success                                        200                {object}        object
//        @failure                                        500                {object}        object
//        @failure                                        401                {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/input/{cascade_name}/update [post]
func UpdateInputDependenciesByName(ctx *gin.Context) <span class="cov4" title="2">{
        name := ctx.Param("cascade")

        var changed []string
        if err := ctx.ShouldBindJSON(&amp;changed); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov4" title="2">err := manager.InputChangeStateChange(name, changed)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov4" title="2">ctx.JSON(http.StatusOK, gin.H{"message": "OK"})</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package api

import (
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "scaffold/server/cascade"
        "scaffold/server/config"
        "scaffold/server/constants"
        "scaffold/server/container"
        "scaffold/server/logger"
        "scaffold/server/manager"
        "scaffold/server/run"
        "scaffold/server/state"
        "scaffold/server/task"
        "scaffold/server/utils"
        "scaffold/server/worker"
        "strings"

        "github.com/gin-gonic/gin"
)

//        @summary                                        Create a run
//        @description                                Create a run to be deployed to a worker
//        @tags                                                worker
//        @tags                                                run
//        @produce                                        json
//        @success                                        200 {object} object
//        @failure                                        500 {object} object
//        @failure                                        401 {object} object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/run/{cascade_name}/{task_name} [post]
func CreateRun(ctx *gin.Context) <span class="cov10" title="3">{
        cn := ctx.Param("cascade")
        tn := ctx.Param("task")

        c, err := cascade.GetCascadeByName(cn)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov10" title="3">s, err := state.GetStateByNames(cn, tn)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov10" title="3">t, err := task.GetTaskByNames(cn, tn)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov10" title="3">t.RunNumber += 1

        previousName := fmt.Sprintf("SCAFFOLD_PREVIOUS-%s", t.Name)
        ps := *s
        ps.Task = previousName
        err = state.UpdateStateByNames(cn, previousName, &amp;ps)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov10" title="3">s.Number += 1

        s.Status = constants.STATE_STATUS_WAITING

        obj := run.Run{
                Name:   fmt.Sprintf("%s.%s.%d", cn, tn, t.RunNumber),
                Task:   *t,
                State:  *s,
                Number: t.RunNumber,
                Groups: c.Groups,
        }
        postBody, _ := json.Marshal(obj)
        postBodyBuffer := bytes.NewBuffer(postBody)

        n, err := getAvailableNode()
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov10" title="3">httpClient := http.Client{}
        requestURL := fmt.Sprintf("%s://%s:%d/api/v1/trigger", n.Protocol, n.Host, n.Port)
        req, _ := http.NewRequest("POST", requestURL, postBodyBuffer)
        req.Header.Set("Authorization", fmt.Sprintf("X-Scaffold-API %s", config.Config.Node.PrimaryKey))
        resp, err := httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov10" title="3">if resp.StatusCode &gt;= 400 </span><span class="cov10" title="3">{
                utils.Error(fmt.Errorf("received trigger status code %d", resp.StatusCode), ctx, resp.StatusCode)
        }</span>
        <span class="cov10" title="3">if _, ok := manager.InProgress[cn]; !ok </span><span class="cov1" title="1">{
                manager.InProgress[cn] = map[string]string{fmt.Sprintf("%s.%d", tn, t.RunNumber): fmt.Sprintf("%s://%s:%d", n.Protocol, n.Host, n.Port)}
                manager.ToCheck[cn] = map[string]string{fmt.Sprintf("%s.%d", tn, t.RunNumber): fmt.Sprintf("%s://%s:%d", n.Protocol, n.Host, n.Port)}
        }</span> else<span class="cov6" title="2"> {
                manager.InProgress[cn][fmt.Sprintf("%s.%d", tn, t.RunNumber)] = fmt.Sprintf("%s://%s:%d", n.Protocol, n.Host, n.Port)
                manager.ToCheck[cn][fmt.Sprintf("%s.%d", tn, t.RunNumber)] = fmt.Sprintf("%s://%s:%d", n.Protocol, n.Host, n.Port)
        }</span>

        <span class="cov10" title="3">if err := task.UpdateTaskByNames(cn, tn, t); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        // if err := state.UpdateStateByNames(cn, tn, s); err != nil {
        //         utils.Error(err, ctx, http.StatusInternalServerError)
        //         return
        // }

        <span class="cov10" title="3">cs, err := cascade.GetCascadeByName(cn)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov10" title="3">manager.SetDependsState(cs, tn)

        ctx.JSON(http.StatusOK, gin.H{"message": "OK"})</span>
}

//        @summary                                        Create a check run
//        @description                                Create a check run to be deployed to a worker
//        @tags                                                worker
//        @tags                                                run
//        @produce                                        json
//        @success                                        200 {object} object
//        @failure                                        500 {object} object
//        @failure                                        401 {object} object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/run/{cascade_name}/{task_name}/check [post]
func CreateCheckRun(ctx *gin.Context) <span class="cov0" title="0">{
        cn := ctx.Param("cascade")
        tn := ctx.Param("task")

        c, err := cascade.GetCascadeByName(cn)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">t, err := task.GetTaskByNames(cn, tn)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">t.Check.RunNumber += 1

        checkStateName := fmt.Sprintf("SCAFFOLD_CHECK-%s", tn)

        s, err := state.GetStateByNames(cn, checkStateName)
        if err != nil </span><span class="cov0" title="0">{
                logger.Infof("", "No existing state for %s/%s found", cn, checkStateName)
                s = &amp;state.State{
                        Task:     checkStateName,
                        Cascade:  cn,
                        Status:   constants.STATE_STATUS_WAITING,
                        Started:  "",
                        Finished: "",
                        Output:   "",
                        Number:   t.RunNumber,
                        Display:  make([]map[string]interface{}, 0),
                }
                if err := state.CreateState(s); err != nil </span><span class="cov0" title="0">{
                        utils.Error(err, ctx, http.StatusInternalServerError)
                        return
                }</span>
        }
        <span class="cov0" title="0">s.Number = t.RunNumber

        obj := run.Run{
                Name: fmt.Sprintf("%s.%s.%d", cn, checkStateName, t.Check.RunNumber),
                Task: task.Task{
                        Name:        checkStateName,
                        Cascade:     t.Cascade,
                        DependsOn:   task.TaskDependsOn{},
                        Image:       t.Check.Image,
                        Run:         t.Check.Run,
                        Store:       t.Check.Store,
                        Load:        t.Check.Load,
                        Env:         t.Check.Env,
                        Inputs:      t.Check.Inputs,
                        Updated:     t.Check.Updated,
                        AutoExecute: true,
                        ShouldRM:    true,
                        RunNumber:   t.RunNumber,
                },
                State:  *s,
                Number: t.RunNumber,
                Groups: c.Groups,
        }
        postBody, _ := json.Marshal(obj)
        postBodyBuffer := bytes.NewBuffer(postBody)

        n, err := getAvailableNode()
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">httpClient := http.Client{}
        requestURL := fmt.Sprintf("%s://%s:%d/api/v1/trigger", n.Protocol, n.Host, n.Port)
        req, _ := http.NewRequest("POST", requestURL, postBodyBuffer)
        req.Header.Set("Authorization", fmt.Sprintf("X-Scaffold-API %s", config.Config.Node.PrimaryKey))
        resp, err := httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("", err.Error())
        }</span>
        <span class="cov0" title="0">if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                logger.Errorf("", "Received trigger status code %d", resp.StatusCode)
        }</span>
        <span class="cov0" title="0">if _, ok := manager.InProgress[cn]; !ok </span><span class="cov0" title="0">{
                manager.InProgress[cn] = map[string]string{fmt.Sprintf("%s.%d", checkStateName, t.Check.RunNumber): fmt.Sprintf("%s://%s:%d", n.Protocol, n.Host, n.Port)}
                manager.ToCheck[cn] = map[string]string{fmt.Sprintf("%s.%d", checkStateName, t.Check.RunNumber): fmt.Sprintf("%s://%s:%d", n.Protocol, n.Host, n.Port)}
        }</span> else<span class="cov0" title="0"> {
                manager.InProgress[cn][fmt.Sprintf("%s.%d", checkStateName, t.Check.RunNumber)] = fmt.Sprintf("%s://%s:%d", n.Protocol, n.Host, n.Port)
                manager.ToCheck[cn][fmt.Sprintf("%s.%d", checkStateName, t.Check.RunNumber)] = fmt.Sprintf("%s://%s:%d", n.Protocol, n.Host, n.Port)
        }</span>

        <span class="cov0" title="0">if err := task.UpdateTaskByNames(cn, tn, t); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        // if err := state.UpdateStateByNames(cn, tn, s); err != nil {
        //         utils.Error(err, ctx, http.StatusInternalServerError)
        //         return
        // }

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{"message": "OK"})</span>
}

//        @summary                                        Kill a run
//        @description                                Instruct a manager to kill a run
//        @tags                                                manager
//        @tags                                                run
//        @success                                        200 {object} object
//        @failure                                        500 {object} object
//        @failure                                        401 {object} object
//        @produce                                         json
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/run/{cascade_name}/{task_name}/{task_number} [delete]
func ManagerKillRun(ctx *gin.Context) <span class="cov0" title="0">{
        cn := ctx.Param("cascade")
        tn := ctx.Param("task")
        nn := ctx.Param("number")

        key := fmt.Sprintf("%s.%s", tn, nn)

        uri := ""
        logger.Debugf("", "Looking for %s/%s.%s", cn, tn, nn)
        logger.Debugf("", "Kill in progress: %s", manager.InProgress)
        if _, ok := manager.InProgress[cn]; ok </span><span class="cov0" title="0">{
                if val, ok := manager.InProgress[cn][key]; ok </span><span class="cov0" title="0">{
                        uri = val
                }</span>
        }

        <span class="cov0" title="0">httpClient := http.Client{}
        requestURL := fmt.Sprintf("%s/api/v1/kill/%s/%s/%s", uri, cn, tn, nn)
        req, _ := http.NewRequest("DELETE", requestURL, nil)
        req.Header.Set("Authorization", fmt.Sprintf("X-Scaffold-API %s", config.Config.Node.PrimaryKey))
        resp, err := httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
        }</span>
        <span class="cov0" title="0">if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                utils.Error(fmt.Errorf("received kill status code %d", resp.StatusCode), ctx, resp.StatusCode)
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{"message": "OK"})</span>
}

//        @summary                                        Trigger a run
//        @description                                Trigger a run on a worker
//        @tags                                                worker
//        @tags                                                run
//        @accept                                                json
//        @Param                                                user        body                run.Run        true        "Run Data"
//        @success                                        201
//        @failure                                        500
//        @failure                                        401
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/trigger [post]
func TriggerRun(ctx *gin.Context) <span class="cov0" title="0">{
        var r run.Run
        if err := ctx.ShouldBindJSON(&amp;r); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if r.Groups != nil </span><span class="cov0" title="0">{
                if !validateUserGroup(ctx, r.Groups) </span><span class="cov0" title="0">{
                        utils.Error(errors.New("user is not part of required groups to access this resources"), ctx, http.StatusUnauthorized)
                        return
                }</span>
        }

        <span class="cov0" title="0">names := strings.Split(r.Name, ".")

        r.State = state.State{
                Task:     names[1],
                Cascade:  names[0],
                Status:   constants.STATE_STATUS_WAITING,
                Started:  "",
                Finished: "",
                Output:   "",
                Number:   r.Number,
                Display:  make([]map[string]interface{}, 0),
        }

        logger.Debugf("", "Writing new run to queue %v", r)

        worker.RunQueue = append(worker.RunQueue, r)

        ctx.Status(http.StatusCreated)</span>
}

//        @summary                                        Kill a run
//        @description                                Kill a run on a worker
//        @tags                                                worker
//        @tags                                                run
//        @success                                        200
//        @failure                                        500
//        @failure                                        401
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/kill/{cascade_name}/{task_name}/{task_number} [delete]
func KillRun(ctx *gin.Context) <span class="cov0" title="0">{
        cn := ctx.Param("cascade")
        tn := ctx.Param("task")
        nn := ctx.Param("number")

        c, err := cascade.GetCascadeByName(cn)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusNotFound)
        }</span>
        <span class="cov0" title="0">if c.Groups != nil </span><span class="cov0" title="0">{
                if !validateUserGroup(ctx, c.Groups) </span><span class="cov0" title="0">{
                        utils.Error(errors.New("user is not part of required groups to access this resources"), ctx, http.StatusUnauthorized)
                }</span>
        }

        <span class="cov0" title="0">if err := run.Kill(cn, tn, nn); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">ctx.Status(http.StatusOK)</span>
}

//        @summary                                        Get run state
//        @description                                Get state of a run being executed on a worker
//        @tags                                                worker
//        @tags                                                run
//        @tags                                                state
//        @produce                                        json
//        @success                                        200        {object}        state.State
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @failure                                        404        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/state/{cascade_name}/{task_name}/{task_number} [get]
func GetRunState(ctx *gin.Context) <span class="cov0" title="0">{
        cn := ctx.Param("cascade")
        tn := ctx.Param("task")
        n := ctx.Param("number")

        c, err := cascade.GetCascadeByName(cn)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusNotFound)
        }</span>
        <span class="cov0" title="0">if c.Groups != nil </span><span class="cov0" title="0">{
                if !validateUserGroup(ctx, c.Groups) </span><span class="cov0" title="0">{
                        utils.Error(errors.New("user is not part of required groups to access this resources"), ctx, http.StatusUnauthorized)
                }</span>
        }

        <span class="cov0" title="0">runName := fmt.Sprintf("%s.%s.%s", cn, tn, n)
        if container.CurrentRun.Name == runName </span><span class="cov0" title="0">{
                logger.Debugf("", "Run %s is currently running", runName)
                ctx.JSON(http.StatusOK, container.CurrentRun.State)
                return
        }</span>
        <span class="cov0" title="0">for _, r := range worker.RunQueue </span><span class="cov0" title="0">{
                if r.Name == runName </span><span class="cov0" title="0">{
                        logger.Debugf("", "Run %s is waiting in queue", runName)
                        ctx.JSON(http.StatusOK, r.State)
                        return
                }</span>
        }
        <span class="cov0" title="0">if r, ok := container.CompletedRuns[runName]; ok </span><span class="cov0" title="0">{
                logger.Debugf("", "Run %s is completed", runName)
                ctx.JSON(http.StatusOK, r.State)
                delete(container.CompletedRuns, runName)
                return
        }</span>
        <span class="cov0" title="0">ctx.Status(http.StatusNotFound)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package api

import (
        "errors"
        "net/http"
        "scaffold/server/cascade"
        "scaffold/server/state"
        "scaffold/server/utils"

        "github.com/gin-gonic/gin"
        "go.mongodb.org/mongo-driver/mongo"
)

//        @summary                                        Create a state
//        @description                                Create a state from a JSON object
//        @tags                                                manager
//        @tags                                                state
//        @accept                                                json
//        @produce                                        json
//        @Param                                                state        body                state.State        true        "State Data"
//        @success                                        201                {object}        object
//        @failure                                        500                {object}        object
//        @failure                                        401                {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/state [post]
func CreateState(ctx *gin.Context) <span class="cov1" title="2">{
        var s state.State
        if err := ctx.ShouldBindJSON(&amp;s); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="2">c, err := cascade.GetCascadeByName(s.Cascade)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusNotFound)
        }</span>
        <span class="cov1" title="2">if c.Groups != nil </span><span class="cov1" title="2">{
                if !validateUserGroup(ctx, c.Groups) </span><span class="cov0" title="0">{
                        utils.Error(errors.New("user is not part of required groups to access this resources"), ctx, http.StatusUnauthorized)
                }</span>
        }

        <span class="cov1" title="2">err = state.CreateState(&amp;s)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="2">ctx.JSON(http.StatusCreated, gin.H{"message": "Created"})</span>
}

//        @summary                                        Delete a state
//        @description                                Delete a state by its name and its cascade
//        @tags                                                manager
//        @tags                                                state
//        @produce                                        json
//        @success                                        200        {object}        object
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/state/{cascade_name}/{state_name} [delete]
func DeleteStateByNames(ctx *gin.Context) <span class="cov1" title="1">{
        cn := ctx.Param("cascade")
        tn := ctx.Param("task")

        err := state.DeleteStateByNames(cn, tn)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">ctx.JSON(http.StatusOK, gin.H{"message": "OK"})</span>
}

//        @summary                                        Delete states
//        @description                                Delete states by their cascade
//        @tags                                                manager
//        @tags                                                state
//        @produce                                        json
//        @success                                        200        {object}        object
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/state/{cascade_name} [delete]
func DeleteStatesByCascade(ctx *gin.Context) <span class="cov1" title="1">{
        cn := ctx.Param("cascade")

        err := state.DeleteStatesByCascade(cn)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">ctx.JSON(http.StatusOK, gin.H{"message": "OK"})</span>
}

//        @summary                                        Get all states
//        @description                                Get all states
//        @tags                                                manager
//        @tags                                                state
//        @produce                                        json
//        @success                                        200        {array}                state.State
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/state [get]
func GetAllStates(ctx *gin.Context) <span class="cov4" title="11">{
        states, err := state.GetAllStates()

        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        ctx.JSON(http.StatusNoContent, []interface{}{})
                        return
                }</span>
                <span class="cov0" title="0">utils.Error(err, ctx, http.StatusInternalServerError)
                return</span>
        }

        <span class="cov4" title="11">statesOut := make([]state.State, 0)
        for _, s := range states </span><span class="cov10" title="612">{
                c, err := cascade.GetCascadeByName(s.Cascade)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov10" title="612">if c.Groups != nil </span><span class="cov9" title="414">{
                        if validateUserGroup(ctx, c.Groups) </span><span class="cov8" title="234">{
                                statesOut = append(statesOut, *s)
                        }</span>
                        <span class="cov9" title="414">continue</span>
                }
                <span class="cov8" title="198">statesOut = append(statesOut, *s)</span>
        }

        <span class="cov4" title="11">ctx.JSON(http.StatusOK, statesOut)</span>
}

//        @summary                                        Get a state
//        @description                                Get a state by its name and its cascade
//        @tags                                                manager
//        @tags                                                state
//        @produce                                        json
//        @success                                        200        {object}        state.State
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/state/{cascade_name}/{state_name} [get]
func GetStateByNames(ctx *gin.Context) <span class="cov4" title="14">{
        cn := ctx.Param("cascade")
        tn := ctx.Param("task")

        s, err := state.GetStateByNames(cn, tn)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov4" title="14">ctx.JSON(http.StatusOK, *s)</span>
}

//        @summary                                        Get states
//        @description                                Get states by their cascade
//        @tags                                                manager
//        @tags                                                state
//        @produce                                        json
//        @success                                        200        {array}                state.State
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/state/{cascade_name} [get]
func GetStatesByCascade(ctx *gin.Context) <span class="cov1" title="1">{
        cn := ctx.Param("cascade")

        s, err := state.GetStatesByCascade(cn)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">ctx.JSON(http.StatusOK, s)</span>
}

//        @summary                                        Update a state
//        @description                                Update a state from a JSON object
//        @tags                                                manager
//        @tags                                                state
//        @accept                                                json
//        @produce                                        json
//        @Param                                                state        body                state.State        true        "State Data"
//        @success                                        201                {object}        object
//        @failure                                        500                {object}        object
//        @failure                                        401                {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/state/{cascade_name}/{state_name} [put]
func UpdateStateByNames(ctx *gin.Context) <span class="cov1" title="1">{
        cn := ctx.Param("cascade")
        tn := ctx.Param("task")

        var s state.State
        if err := ctx.ShouldBindJSON(&amp;s); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">err := state.UpdateStateByNames(cn, tn, &amp;s)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">ctx.JSON(http.StatusOK, gin.H{"message": "OK"})</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package api

import (
        "errors"
        "net/http"
        "scaffold/server/cascade"
        "scaffold/server/task"
        "scaffold/server/utils"

        "github.com/gin-gonic/gin"
        "go.mongodb.org/mongo-driver/mongo"
)

//        @summary                                        Create a task
//        @description                                Create a task from a JSON object
//        @tags                                                manager
//        @tags                                                task
//        @accept                                                json
//        @produce                                        json
//        @Param                                                task        body                task.Task        true        "Task Data"
//        @success                                        201                {object}        object
//        @failure                                        500                {object}        object
//        @failure                                        401                {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/task [post]
func CreateTask(ctx *gin.Context) <span class="cov2" title="2">{
        var t task.Task
        if err := ctx.ShouldBindJSON(&amp;t); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov2" title="2">c, err := cascade.GetCascadeByName(t.Cascade)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusNotFound)
        }</span>
        <span class="cov2" title="2">if c.Groups != nil </span><span class="cov2" title="2">{
                if !validateUserGroup(ctx, c.Groups) </span><span class="cov0" title="0">{
                        utils.Error(errors.New("user is not part of required groups to access this resources"), ctx, http.StatusUnauthorized)
                }</span>
        }

        <span class="cov2" title="2">err = task.CreateTask(&amp;t)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov2" title="2">ctx.JSON(http.StatusCreated, gin.H{"message": "Created"})</span>
}

//        @summary                                        Delete a task
//        @description                                Delete a task by its name and its cascade
//        @tags                                                manager
//        @tags                                                task
//        @produce                                        json
//        @success                                        200        {object}        object
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/task/{task_name} [delete]
func DeleteTaskByNames(ctx *gin.Context) <span class="cov1" title="1">{
        cn := ctx.Param("cascade")
        tn := ctx.Param("task")

        err := task.DeleteTaskByNames(cn, tn)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">ctx.JSON(http.StatusOK, gin.H{"message": "OK"})</span>
}

//        @summary                                        Delete tasks
//        @description                                Delete tasks by their cascade
//        @tags                                                manager
//        @tags                                                task
//        @produce                                        json
//        @success                                        200        {object}        object
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/task/{cascade_name} [delete]
func DeleteTasksByCascade(ctx *gin.Context) <span class="cov1" title="1">{
        cn := ctx.Param("cascade")

        err := task.DeleteTasksByCascade(cn)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">ctx.JSON(http.StatusOK, gin.H{"message": "OK"})</span>
}

//        @summary                                        Get all tasks
//        @description                                Get all tasks
//        @tags                                                manager
//        @tags                                                task
//        @produce                                        json
//        @success                                        200        {array}                task.Task
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/task [get]
func GetAllTasks(ctx *gin.Context) <span class="cov5" title="11">{
        tasks, err := task.GetAllTasks()

        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        ctx.JSON(http.StatusNoContent, []interface{}{})
                        return
                }</span>
                <span class="cov0" title="0">utils.Error(err, ctx, http.StatusInternalServerError)
                return</span>
        }

        <span class="cov5" title="11">tasksOut := make([]task.Task, 0)
        for _, t := range tasks </span><span class="cov10" title="204">{
                c, err := cascade.GetCascadeByName(t.Cascade)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov10" title="204">if c.Groups != nil </span><span class="cov9" title="138">{
                        if validateUserGroup(ctx, c.Groups) </span><span class="cov8" title="78">{
                                tasksOut = append(tasksOut, *t)
                        }</span>
                        <span class="cov9" title="138">continue</span>
                }
                <span class="cov8" title="66">tasksOut = append(tasksOut, *t)</span>
        }

        <span class="cov5" title="11">ctx.JSON(http.StatusOK, tasksOut)</span>
}

//        @summary                                        Get a task
//        @description                                Get a task by its name and its cascade
//        @tags                                                manager
//        @tags                                                task
//        @produce                                        json
//        @success                                        200        {object}        task.Task
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/task/{cascade_name}/{task_name} [get]
func GetTaskByNames(ctx *gin.Context) <span class="cov4" title="10">{
        cn := ctx.Param("cascade")
        tn := ctx.Param("task")

        t, err := task.GetTaskByNames(cn, tn)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov4" title="10">ctx.JSON(http.StatusOK, *t)</span>
}

//        @summary                                        Get tasks
//        @description                                Get tasks by their cascade
//        @tags                                                manager
//        @tags                                                task
//        @produce                                        json
//        @success                                        200        {array}                task.Task
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/task/{cascade_name} [get]
func GetTasksByCascade(ctx *gin.Context) <span class="cov1" title="1">{
        cn := ctx.Param("cascade")

        t, err := task.GetTasksByCascade(cn)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">ctx.JSON(http.StatusOK, t)</span>
}

//        @summary                                        Update a task
//        @description                                Update a task from a JSON object
//        @tags                                                manager
//        @tags                                                task
//        @accept                                                json
//        @produce                                        json
//        @Param                                                task        body                task.Task        true        "Task Data"
//        @success                                        201                {object}        object
//        @failure                                        500                {object}        object
//        @failure                                        401                {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/task/{cascade_name}/{task_name} [put]
func UpdateTaskByNames(ctx *gin.Context) <span class="cov1" title="1">{
        cn := ctx.Param("cascade")
        tn := ctx.Param("task")

        var t task.Task
        if err := ctx.ShouldBindJSON(&amp;t); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">err := task.UpdateTaskByNames(cn, tn, &amp;t)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">ctx.JSON(http.StatusOK, gin.H{"message": "OK"})</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package api

import (
        "net/http"
        "scaffold/server/user"
        "scaffold/server/utils"

        "github.com/gin-gonic/gin"
        "go.mongodb.org/mongo-driver/mongo"
)

//        @summary                                        Create a user
//        @description                                Create a user from a JSON object
//        @tags                                                manager
//        @tags                                                user
//        @accept                                                json
//        @produce                                        json
//        @Param                                                user        body                user.User        true        "User Data"
//        @success                                        201                {object}        object
//        @failure                                        500                {object}        object
//        @failure                                        401                {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/user [post]
func CreateUser(ctx *gin.Context) <span class="cov10" title="4">{
        var u user.User
        if err := ctx.ShouldBindJSON(&amp;u); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov10" title="4">err := user.CreateUser(&amp;u)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov10" title="4">ctx.JSON(http.StatusCreated, gin.H{"message": "Created"})</span>
}

//        @summary                                        Delete a user
//        @description                                Delete a user by its username
//        @tags                                                manager
//        @tags                                                user
//        @produce                                        json
//        @success                                        200        {object}        object
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/user/{username} [delete]
func DeleteUserByUsername(ctx *gin.Context) <span class="cov0" title="0">{
        username := ctx.Param("username")

        err := user.DeleteUserByUsername(username)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{"message": "OK"})</span>
}

//        @summary                                        Get all users
//        @description                                Get all users
//        @tags                                                manager
//        @tags                                                user
//        @produce                                        json
//        @success                                        200        {array}                user.User
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/user [get]
func GetAllUsers(ctx *gin.Context) <span class="cov0" title="0">{
        users, err := user.GetAllUsers()

        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        ctx.JSON(http.StatusNoContent, []interface{}{})
                        return
                }</span>
                <span class="cov0" title="0">utils.Error(err, ctx, http.StatusInternalServerError)
                return</span>
        }

        <span class="cov0" title="0">usersOut := make([]user.User, len(users))
        for idx, u := range users </span><span class="cov0" title="0">{
                usersOut[idx] = *u
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, usersOut)</span>
}

//        @summary                                        Get a user
//        @description                                Get a user by its username
//        @tags                                                manager
//        @tags                                                user
//        @produce                                        json
//        @success                                        200        {array}                user.User
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/user/{username} [get]
func GetUserByUsername(ctx *gin.Context) <span class="cov0" title="0">{
        username := ctx.Param("username")

        u, err := user.GetUserByUsername(username)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, *u)</span>
}

//        @summary                                        Update a user
//        @description                                Update a user from a JSON object
//        @tags                                                manager
//        @tags                                                user
//        @accept                                                json
//        @produce                                        json
//        @Param                                                user        body                user.User        true        "User Data"
//        @success                                        201                {object}        object
//        @failure                                        500                {object}        object
//        @failure                                        401                {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/user/{user_name} [put]
func UpdateUserByUsername(ctx *gin.Context) <span class="cov0" title="0">{
        username := ctx.Param("username")

        var u user.User
        if err := ctx.ShouldBindJSON(&amp;u); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">uu, err := user.GetUserByUsername(username)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">uu.GivenName = u.GivenName
        uu.FamilyName = u.FamilyName
        uu.Email = u.Email
        uu.Groups = u.Groups
        uu.Roles = u.Roles

        if uu.Password != u.Password </span><span class="cov0" title="0">{
                uu.Password, err = user.HashAndSalt([]byte(u.Password))
                if err != nil </span><span class="cov0" title="0">{
                        utils.Error(err, ctx, http.StatusInternalServerError)
                        return
                }</span>
        }

        <span class="cov0" title="0">err = user.UpdateUserByUsername(username, uu)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{"message": "OK"})</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package auth

import (
        "crypto/tls"
        "net/http"
        "scaffold/server/cascade"
        "scaffold/server/config"
        "scaffold/server/logger"
        "scaffold/server/user"
        "scaffold/server/utils"
        "strings"
        "time"

        "encoding/base64"

        "github.com/gin-gonic/gin"
        "golang.org/x/crypto/bcrypt"
        "gopkg.in/gomail.v2"
)

type PasswordResetObject struct {
        Password        string `json:"password"`
        ConfirmPassword string `json:"confirm_password"`
        Email           string `json:"email"`
}

type NodeJoinObject struct {
        Name     string `json:"name"`
        Host     string `json:"host"`
        Port     int    `json:"port"`
        WSPort   int    `json:"ws_port"`
        Protocol string `json:"protocol"`
        JoinKey  string `json:"join_key"`
        Version  string `json:"version"`
}

type NodeObject struct {
        Name      string `json:"name" bson:"name"`
        Host      string `json:"host" bson:"host"`
        Port      int    `json:"port" bson:"port"`
        WSPort    int    `json:"ws_port" bson:"ws_port"`
        Protocol  string `json:"protocol"`
        Healthy   bool   `json:"healthy" bson:"healthy"`
        Available bool   `json:"available" bson:"available"`
        Version   string `json:"version" bson:"version"`
}

type DegradedNodeObject struct {
        Count int
        Node  NodeObject
}

var Nodes []NodeObject
var UnknownNodes map[string]DegradedNodeObject
var UnhealthyNodes map[string]DegradedNodeObject
var LastScheduledIdx = 0

func PerformLogin(c *gin.Context) <span class="cov0" title="0">{
        username := c.PostForm("username")
        password := c.PostForm("password")

        rememberMe := c.PostForm("remember_me")

        if username == "" || password == "" </span><span class="cov0" title="0">{
                if val, ok := c.Request.Header["Authorization"]; ok </span><span class="cov0" title="0">{
                        authToken := strings.Split(val[0], " ")[1]
                        authTokenBytes, _ := base64.StdEncoding.DecodeString(authToken)
                        authData := strings.Split(string(authTokenBytes), ":")

                        username = authData[0]
                        password = authData[1]

                        valid, _ := user.VerifyUser(username, password)
                        if valid </span><span class="cov0" title="0">{
                                token := utils.GenerateToken(32)
                                c.SetCookie("scaffold_token", token, 3600, "", "", false, false)
                                u, _ := user.GetUserByUsername(username)
                                hashedToken, err := HashAndSalt([]byte(token))
                                if err != nil </span><span class="cov0" title="0">{
                                        c.HTML(http.StatusBadRequest, "login.html", gin.H{
                                                "ErrorTitle":   "Login Failed",
                                                "ErrorMessage": err.Error()})
                                }</span>
                                <span class="cov0" title="0">u.LoginToken = hashedToken
                                user.UpdateUserByUsername(username, u)
                                return</span>
                        }
                }
        } else<span class="cov0" title="0"> {
                valid, err := user.VerifyUser(username, password)
                if valid </span><span class="cov0" title="0">{
                        token := utils.GenerateToken(32)
                        if rememberMe == "on" </span><span class="cov0" title="0">{
                                c.SetCookie("scaffold_token", token, 604800, "", "", false, false)
                        }</span> else<span class="cov0" title="0"> {
                                c.SetCookie("scaffold_token", token, 3600, "", "", false, false)
                        }</span>

                        <span class="cov0" title="0">u, _ := user.GetUserByUsername(username)
                        hashedToken, err := HashAndSalt([]byte(token))
                        if err != nil </span><span class="cov0" title="0">{
                                c.HTML(http.StatusBadRequest, "login.html", gin.H{
                                        "ErrorTitle":   "Login Failed",
                                        "ErrorMessage": err.Error()})
                        }</span>
                        <span class="cov0" title="0">u.LoginToken = hashedToken
                        user.UpdateUserByUsername(username, u)

                        c.Redirect(302, "/")
                        return</span>
                } else<span class="cov0" title="0"> {
                        c.HTML(http.StatusBadRequest, "login.html", gin.H{
                                "ErrorTitle":   "Login Failed",
                                "ErrorMessage": err.Error()})
                }</span>
        }
        <span class="cov0" title="0">c.AbortWithStatus(http.StatusUnauthorized)</span>
}

func PerformLogout(c *gin.Context) <span class="cov0" title="0">{
        token, err := c.Cookie("scaffold_token")

        if err != nil </span><span class="cov0" title="0">{
                u, err := user.GetUserByLoginToken(token)
                if err != nil </span><span class="cov0" title="0">{
                        u.LoginToken = ""
                        user.UpdateUserByUsername(u.Username, u)
                }</span>
        }
        <span class="cov0" title="0">c.SetCookie("scaffold_token", "", -1, "", "", false, true)

        c.Redirect(http.StatusTemporaryRedirect, "/")</span>
}

func RequestPasswordReset(c *gin.Context) <span class="cov0" title="0">{
        email := c.PostForm("email")

        u, _ := user.GetUserByEmail(email)

        if u != nil </span><span class="cov0" title="0">{
                token := utils.GenerateToken(32)
                currentTime := time.Now()

                hashedToken, err := HashAndSalt([]byte(token))
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
                <span class="cov0" title="0">u.ResetToken = hashedToken
                u.ResetTokenCreated = currentTime.Format("2006-01-02 15:04:05")
                user.UpdateUserByUsername(u.Username, u)

                m := gomail.NewMessage()

                // Set E-Mail sender
                m.SetHeader("From", config.Config.Reset.Email)

                // Set E-Mail receivers
                m.SetHeader("To", email)

                // Set E-Mail subject
                m.SetHeader("Subject", "Scaffold Password Reset")

                // Set E-Mail body. You can set plain text or html with text/html
                m.SetBody("text/html", "&lt;p&gt;To reset your Scaffold account password, click on the following link or paste it into your browser:&lt;/p&gt;&lt;br&gt;&lt;a href=\""+config.Config.BaseURL+"/ui/reset_password/"+token+"\"&gt;"+config.Config.BaseURL+"/ui/reset_password/"+token+"&lt;/a&gt;&lt;br&gt;This link will expire after 24 hours.")

                // Settings for SMTP server
                d := gomail.NewDialer(config.Config.Reset.Host, config.Config.Reset.Port, config.Config.Reset.Email, config.Config.Reset.Password)

                // This is only needed when SSL/TLS certificate is not valid on server.
                // In production this should be set to false.
                d.TLSConfig = &amp;tls.Config{InsecureSkipVerify: true}

                // Now send E-Mail
                if err := d.DialAndSend(m); err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("", err.Error())
                }</span>
                <span class="cov0" title="0">c.Redirect(302, "/ui/email_success")</span>
        } else<span class="cov0" title="0"> {
                c.Redirect(302, "/ui/email_failure")
        }</span>
}

func DoPasswordReset(c *gin.Context) <span class="cov0" title="0">{
        r := PasswordResetObject{}

        err := c.ShouldBindJSON(&amp;r)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">if r.Password != r.ConfirmPassword </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "passwords do not match"})
        }</span>
        <span class="cov0" title="0">u, err := user.GetUserByEmail(r.Email)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">u.Password, err = HashAndSalt([]byte(r.Password))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        }</span>
        <span class="cov0" title="0">user.UpdateUserByUsername(u.Username, u)
        c.JSON(http.StatusOK, gin.H{})</span>
}

func HashAndSalt(pwd []byte) (string, error) <span class="cov0" title="0">{
        hash, err := bcrypt.GenerateFromPassword(pwd, bcrypt.MinCost)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov0" title="0">return string(hash), nil</span>
}

func JoinNode(ctx *gin.Context) <span class="cov8" title="1">{
        var n NodeJoinObject
        if err := ctx.ShouldBindJSON(&amp;n); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">if n.JoinKey == config.Config.Node.JoinKey </span><span class="cov8" title="1">{
                logger.Debugf("", "Joining node %s, %d, %d", n.Host, n.Port, n.WSPort)
                Nodes = append(Nodes, NodeObject{
                        Host:     n.Host,
                        Port:     n.Port,
                        WSPort:   n.WSPort,
                        Healthy:  true,
                        Version:  n.Version,
                        Protocol: n.Protocol,
                })
                ctx.Status(http.StatusOK)
                return
        }</span>

        <span class="cov0" title="0">ctx.Status(http.StatusUnauthorized)</span>
}

func GetAllGroups() ([]string, error) <span class="cov0" title="0">{
        groups := []string{}

        cascades, err := cascade.GetAllCascades()
        if err != nil </span><span class="cov0" title="0">{
                return []string{}, err
        }</span> else<span class="cov0" title="0"> {
                for _, c := range cascades </span><span class="cov0" title="0">{
                        for _, group := range c.Groups </span><span class="cov0" title="0">{
                                if !utils.Contains(groups, group) </span><span class="cov0" title="0">{
                                        groups = append(groups, group)
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">users, err := user.GetAllUsers()
        if err != nil </span><span class="cov0" title="0">{
                return []string{}, err
        }</span> else<span class="cov0" title="0"> {
                for _, u := range users </span><span class="cov0" title="0">{
                        for _, group := range u.Groups </span><span class="cov0" title="0">{
                                if !utils.Contains(groups, group) </span><span class="cov0" title="0">{
                                        groups = append(groups, group)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return groups, nil</span>
}

func GetAllRoles() []string <span class="cov0" title="0">{
        return []string{"read", "write", "admin"}
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package cascade

import (
        "fmt"
        "scaffold/server/constants"
        "scaffold/server/datastore"
        "scaffold/server/input"
        "scaffold/server/logger"
        "scaffold/server/state"
        "scaffold/server/task"
        "scaffold/server/utils"
        "time"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"

        "scaffold/server/mongodb"
)

type Cascade struct {
        Version string            `json:"version" bson:"version"`
        Name    string            `json:"name" bson:"name"`
        Inputs  []input.Input     `json:"inputs" bson:"inputs"`
        Tasks   []task.Task       `json:"tasks" bson:"tasks"`
        Created string            `json:"created" bson:"created"`
        Updated string            `json:"updated" bson:"updated"`
        Groups  []string          `json:"groups" bson:"groups"`
        Links   map[string]string `json:"links" bson:"links"`
}

func CreateCascade(c *Cascade) error <span class="cov3" title="5">{
        currentTime := time.Now().UTC()
        c.Created = currentTime.Format("2006-01-02T15:04:05Z")
        c.Updated = currentTime.Format("2006-01-02T15:04:05Z")

        if _, err := GetCascadeByName(c.Name); err == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cascade already exists with name %s", c.Name)
        }</span>

        <span class="cov3" title="5">_, err := mongodb.Collections[constants.MONGODB_CASCADE_COLLECTION_NAME].InsertOne(mongodb.Ctx, c)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="5">for _, t := range c.Tasks </span><span class="cov5" title="30">{
                t.Cascade = c.Name
                t.RunNumber = 0
                if err := task.CreateTask(&amp;t); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov3" title="5">for _, i := range c.Inputs </span><span class="cov3" title="9">{
                i.Cascade = c.Name
                if err := input.CreateInput(&amp;i); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov3" title="5">d := &amp;datastore.DataStore{
                Name:    c.Name,
                Env:     make(map[string]string),
                Files:   make([]string, 0),
                Created: c.Created,
                Updated: c.Updated,
        }

        for _, val := range c.Inputs </span><span class="cov3" title="9">{
                d.Env[val.Name] = val.Default
        }</span>

        <span class="cov3" title="5">err = datastore.CreateDataStore(d)
        return err</span>
}

func DeleteCascadeByName(name string) error <span class="cov1" title="1">{
        filter := bson.M{"name": name}

        collection := mongodb.Collections[constants.MONGODB_CASCADE_COLLECTION_NAME]
        ctx := mongodb.Ctx

        result, err := collection.DeleteOne(ctx, filter)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">if result.DeletedCount != 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("no cascade found with name %s", name)
        }</span>

        <span class="cov1" title="1">if err := task.DeleteTasksByCascade(name); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">if err := input.DeleteInputsByCascade(name); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">err = datastore.DeleteDataStoreByCascade(name)
        return err</span>

}

func GetAllCascades() ([]*Cascade, error) <span class="cov7" title="127">{
        filter := bson.M{}

        cascades, err := FilterCascades(filter)

        return cascades, err
}</span>

func GetCascadeByName(name string) (*Cascade, error) <span class="cov9" title="976">{
        filter := bson.M{"name": name}

        cascades, err := FilterCascades(filter)

        if err != nil </span><span class="cov4" title="11">{
                return nil, err
        }</span>

        <span class="cov9" title="965">if len(cascades) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no cascade found with name %s", name)
        }</span>

        <span class="cov9" title="965">if len(cascades) &gt; 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("multiple cascades found with name %s", name)
        }</span>

        <span class="cov9" title="965">return cascades[0], nil</span>
}

func UpdateCascadeByName(name string, c *Cascade) error <span class="cov1" title="1">{
        filter := bson.M{"name": name}

        currentTime := time.Now().UTC()
        c.Updated = currentTime.Format("2006-01-02T15:04:05Z")

        collection := mongodb.Collections[constants.MONGODB_CASCADE_COLLECTION_NAME]
        ctx := mongodb.Ctx

        opts := options.Replace().SetUpsert(true)

        states, err := state.GetStatesByCascade(name)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">tasks, err := task.GetTasksByCascade(name)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov1" title="1">result, err := collection.ReplaceOne(ctx, filter, c, opts)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">if result.ModifiedCount != 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("no cascade found with name %s", name)
        }</span>

        <span class="cov1" title="1">taskNames := make([]string, len(states))

        for idx, t := range tasks </span><span class="cov3" title="6">{
                taskNames[idx] = t.Name
        }</span>

        <span class="cov1" title="1">newNames := make([]string, len(c.Tasks))

        for idx, t := range c.Tasks </span><span class="cov3" title="6">{
                if !utils.Contains(taskNames, t.Name) </span><span class="cov0" title="0">{
                        t.Cascade = name
                        logger.Debugf("", "Creating task %s with cascade %s", t.Name, t.Cascade)
                        if err := task.CreateTask(&amp;t); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov3" title="6">logger.Debugf("", "Updating task %s with cascade %s", t.Name, name)
                if err := task.UpdateTaskByNames(name, t.Name, &amp;t); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov3" title="6">newNames[idx] = t.Name</span>
        }

        <span class="cov1" title="1">logger.Debugf("", "Old tasks: %v", taskNames)
        logger.Debugf("", "New tasks: %v", newNames)

        for _, t := range tasks </span><span class="cov3" title="6">{
                if !utils.Contains(newNames, t.Name) </span><span class="cov0" title="0">{
                        logger.Debugf("", "Removing task %s", t.Name)
                        if err := task.DeleteTaskByNames(name, t.Name); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov1" title="1">return err</span>
}

func FilterCascades(filter interface{}) ([]*Cascade, error) <span class="cov10" title="1103">{
        // A slice of tasks for storing the decoded documents
        var cascades []*Cascade

        collection := mongodb.Collections[constants.MONGODB_CASCADE_COLLECTION_NAME]
        ctx := mongodb.Ctx

        cur, err := collection.Find(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return cascades, err
        }</span>

        <span class="cov10" title="1103">for cur.Next(ctx) </span><span class="cov9" title="1047">{
                var c Cascade
                err := cur.Decode(&amp;c)
                if err != nil </span><span class="cov0" title="0">{
                        return cascades, err
                }</span>

                <span class="cov9" title="1047">cascades = append(cascades, &amp;c)</span>
        }

        <span class="cov10" title="1103">if err := cur.Err(); err != nil </span><span class="cov0" title="0">{
                return cascades, err
        }</span>

        // once exhausted, close the cursor
        <span class="cov10" title="1103">cur.Close(ctx)

        if len(cascades) == 0 </span><span class="cov7" title="113">{
                return cascades, mongo.ErrNoDocuments
        }</span>

        <span class="cov9" title="990">return cascades, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package cmd

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "log"
        "net/http"
        "os"
        "os/exec"
        "os/signal"
        "scaffold/server/config"
        "scaffold/server/logger"
        "sort"
        "syscall"
        "time"
        "unicode/utf8"

        _ "embed"

        "github.com/creack/pty"
        "github.com/google/uuid"
        "github.com/gorilla/mux"
        "golang.org/x/net/websocket"
)

// wait time for server start
var waitTime = 500
var checkProcInterval = 5

type Event string

const (
        EventResize  Event = "resize"
        EventSendkey Event = "sendKey"
        EventClose   Event = "close"
)

type Message struct {
        Event Event       `json:"event"`
        Data  interface{} `json:"data"`
}

type Connection struct {
        PTMX    *os.File
        ExecCmd *exec.Cmd
        Image   string
        Done    bool
        Name    string
}

var connections []Connection

func (c *Connection) run(ws *websocket.Conn) <span class="cov0" title="0">{

        vars := mux.Vars(ws.Request())

        cascade := vars["cascade"]
        run := vars["run"]
        version := vars["version"]

        id := uuid.New().String()

        // parts := strings.Split(name, ".")
        runDir := fmt.Sprintf("/tmp/run/%s/%s/%s", cascade, run, version)
        containerName := fmt.Sprintf("%s-%s-%s", cascade, run, version)
        c.Image = containerName
        c.Name = containerName

        commitCommand := fmt.Sprintf("podman commit %s %s/%s", containerName, id, containerName)

        out, err := exec.Command("bash", "-c", commitCommand).CombinedOutput()
        logger.Debugf("", "podman commit: %s", string(out))
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("", err.Error())
        }</span>

        <span class="cov0" title="0">podmanCommand := "podman run --rm --privileged --security-opt label=disabled -it "
        podmanCommand += fmt.Sprintf("--mount type=bind,src=%s,dst=/tmp/run ", runDir)
        podmanCommand += fmt.Sprintf("%s/%s ", id, containerName)
        podmanCommand += "sh"

        logger.Debugf("", "Podman websocket command: %s", podmanCommand)

        c.Name = containerName

        defer ws.Close()

        wsconn := &amp;wsConn{
                conn: ws,
        }

        if c.PTMX == nil </span><span class="cov0" title="0">{
                var msg Message
                if err := json.NewDecoder(ws).Decode(&amp;msg); err != nil </span><span class="cov0" title="0">{
                        log.Println("failed to decode message:", err)
                        return
                }</span>

                <span class="cov0" title="0">rows, cols, err := windowSize(msg.Data)
                if err != nil </span><span class="cov0" title="0">{
                        _, _ = ws.Write([]byte(fmt.Sprintf("%s\r\n", err)))
                        return
                }</span>
                <span class="cov0" title="0">winsize := &amp;pty.Winsize{
                        Rows: rows,
                        Cols: cols,
                }

                pc := []string{"bash", "-c", podmanCommand}
                c.ExecCmd = exec.Command(pc[0], pc[1:]...)

                c.PTMX, err = pty.StartWithSize(c.ExecCmd, winsize)
                if err != nil </span><span class="cov0" title="0">{
                        log.Println("failed to create pty", err)
                        return
                }</span>
        }

        // write data to process
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        var msg Message
                        if err := json.NewDecoder(ws).Decode(&amp;msg); err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Error decoding JSON: %s\n", err.Error())
                                return
                        }</span>

                        <span class="cov0" title="0">if msg.Event == EventClose </span><span class="cov0" title="0">{
                                log.Println("close websocket")
                                ws.Close()
                                return
                        }</span>

                        <span class="cov0" title="0">if msg.Event == EventResize </span><span class="cov0" title="0">{
                                log.Println("do resize")
                                rows, cols, err := windowSize(msg.Data)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Println(err)
                                        return
                                }</span>

                                <span class="cov0" title="0">winsize := &amp;pty.Winsize{
                                        Rows: rows,
                                        Cols: cols,
                                }

                                if err := pty.Setsize(c.PTMX, winsize); err != nil </span><span class="cov0" title="0">{
                                        log.Println("failed to set window size:", err)
                                        return
                                }</span>
                                <span class="cov0" title="0">fmt.Println("resize done")
                                continue</span>
                        }

                        <span class="cov0" title="0">data, ok := msg.Data.(string)
                        if !ok </span><span class="cov0" title="0">{
                                log.Println("invalid message data:", data)
                                return
                        }</span>

                        <span class="cov0" title="0">_, err := c.PTMX.WriteString(data)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Println("failed to write data to ptmx:", err)
                                return
                        }</span>
                }
        }()

        <span class="cov0" title="0">go c.ExecuteCommand()

        _, _ = io.Copy(wsconn, c.PTMX)</span>

}

type wsConn struct {
        conn *websocket.Conn
        buf  []byte
}

// Checking and buffering `b`
// If `b` is invalid UTF-8, it would be buffered
// if buffer is valid UTF-8, it would write to connection
func (ws *wsConn) Write(b []byte) (i int, err error) <span class="cov0" title="0">{
        if !utf8.Valid(b) </span><span class="cov0" title="0">{
                buflen := len(ws.buf)
                blen := len(b)
                ws.buf = append(ws.buf, b...)[:buflen+blen]
                if utf8.Valid(ws.buf) </span><span class="cov0" title="0">{
                        _, e := ws.conn.Write(ws.buf)
                        ws.buf = ws.buf[:0]
                        return blen, e
                }</span>
                <span class="cov0" title="0">return blen, nil</span>
        }

        <span class="cov0" title="0">if len(ws.buf) &gt; 0 </span><span class="cov0" title="0">{
                n, err := ws.conn.Write(ws.buf)
                ws.buf = ws.buf[:0]
                if err != nil </span><span class="cov0" title="0">{
                        return n, err
                }</span>
        }
        <span class="cov0" title="0">n, e := ws.conn.Write(b)
        return n, e</span>
}

func (c *Connection) ExecuteCommand() <span class="cov0" title="0">{
        state, err := c.ExecCmd.Process.Wait()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">logger.Debugf("", "Run exit code: %d", state.ExitCode())

        rmCommand := fmt.Sprintf("podman rm -f %s", c.Name)
        out, err := exec.Command("bash", "-c", rmCommand).CombinedOutput()
        logger.Debugf("", "Podman rm: %s", string(out))
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("", err.Error())
        }</span>

        <span class="cov0" title="0">rmiCommand := fmt.Sprintf("podman rmi -f %s", c.Image)
        out, err = exec.Command("bash", "-c", rmiCommand).CombinedOutput()
        logger.Debugf("", "Podman rmi: %s", string(out))
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("", err.Error())
        }</span>

        <span class="cov0" title="0">if state.ExitCode() != -1 </span><span class="cov0" title="0">{
                c.PTMX.Close()
                c.PTMX = nil
                c.ExecCmd = nil
        }</span>

        <span class="cov0" title="0">c.Done = true</span>
}

func PruneConnections() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                toRemove := []int{}
                for idx, c := range connections </span><span class="cov0" title="0">{
                        logger.Debugf("", "Runing container %s", c.Name)
                        if c.Done </span><span class="cov0" title="0">{
                                toRemove = append(toRemove, idx)
                        }</span>
                }

                <span class="cov0" title="0">sort.Sort(sort.Reverse(sort.IntSlice(toRemove)))

                for _, idx := range toRemove </span><span class="cov0" title="0">{
                        connections = append(connections[:idx], connections[idx+1:]...)
                }</span>
        }
}

func StartWSServer() <span class="cov8" title="1">{

        var serverErr error
        // r := http.NewServeMux()
        r := mux.NewRouter()
        // mux.Handle("/ws", websocket.Handler(run))
        r.HandleFunc("/ws/{cascade}/{run}/{version}",
                func(w http.ResponseWriter, req *http.Request) </span><span class="cov0" title="0">{
                        c := Connection{}
                        s := websocket.Server{Handler: websocket.Handler(c.run)}
                        connections = append(connections, c)
                        s.ServeHTTP(w, req)
                }</span>)

        <span class="cov8" title="1">server := &amp;http.Server{
                Addr:    fmt.Sprintf(":%d", config.Config.WSPort),
                Handler: r,
        }

        go func() </span><span class="cov8" title="1">{
                log.Printf("running %s://0.0.0.0:%d\n", config.Config.Protocol, config.Config.WSPort)

                if config.Config.TLSEnabled </span><span class="cov0" title="0">{
                        if serverErr := server.ListenAndServeTLS(config.Config.TLSCrtPath, config.Config.TLSKeyPath); serverErr != nil </span><span class="cov0" title="0">{
                                logger.Fatalf("", "Error running websocket server: %s", serverErr)
                        }</span>
                } else<span class="cov8" title="1"> {
                        if serverErr := server.ListenAndServe(); serverErr != nil </span><span class="cov0" title="0">{
                                logger.Fatalf("", "Error running websocket server: %s", serverErr)
                        }</span>
                }
        }()

        // wait for run server
        <span class="cov8" title="1">time.Sleep(time.Duration(waitTime) * time.Microsecond)

        if serverErr == nil </span><span class="cov8" title="1">{
                fmt.Println("Server ready")
        }</span>

        <span class="cov8" title="1">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGTERM, os.Interrupt)
        &lt;-quit

        go PruneConnections()

        for _, c := range connections </span><span class="cov0" title="0">{
                if c.PTMX != nil </span><span class="cov0" title="0">{
                        _ = c.PTMX.Close()
                }</span>
                <span class="cov0" title="0">if c.ExecCmd != nil </span><span class="cov0" title="0">{
                        _ = c.ExecCmd.Process.Kill()
                        _, _ = c.ExecCmd.Process.Wait()
                }</span>
        }
        <span class="cov0" title="0">if err := server.Shutdown(context.Background()); err != nil </span><span class="cov0" title="0">{
                log.Println("failed to shutdown server", err)
        }</span>
        <span class="cov0" title="0">fmt.Println("Server has been shut down")</span>
}

func filter(ss []string) []string <span class="cov0" title="0">{
        rs := []string{}

        for _, s := range ss </span><span class="cov0" title="0">{
                if s == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">rs = append(rs, s)</span>
        }

        <span class="cov0" title="0">return rs</span>
}

func getenv(key, def string) string <span class="cov0" title="0">{
        v := os.Getenv(key)
        if v != "" </span><span class="cov0" title="0">{
                return v
        }</span>
        <span class="cov0" title="0">return def</span>
}

func windowSize(msg interface{}) (rows, cols uint16, err error) <span class="cov0" title="0">{
        data, ok := msg.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return 0, 0, fmt.Errorf("invalid message: %#+v", msg)
        }</span>

        <span class="cov0" title="0">rows = uint16(data["rows"].(float64))
        cols = uint16(data["cols"].(float64))

        return</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package config

import (
        "encoding/json"
        "errors"
        "io/ioutil"
        "log"
        "net"
        "net/url"
        "os"
        "reflect"
        "scaffold/server/constants"
        "strconv"
)

const DEFAULT_CONFIG_PATH = "/home/scaffold/data/config.json"
const ENV_PREFIX = "SCAFFOLD_"

type ConfigObject struct {
        Host               string          `json:"host"`
        Port               int             `json:"port"`
        Protocol           string          `json:"protocol"`
        WSPort             int             `json:"ws_port" env:"WS_PORT"`
        LogLevel           string          `json:"log_level" env:"LOG_LEVEL"`
        LogFormat          string          `json:"log_format" env:"LOG_FORMAT"`
        BaseURL            string          `json:"base_url" env:"BASE_URL"`
        Admin              UserObject      `json:"admin" env:"ADMIN"`
        DBConnectionString string          `json:"db_connection_string" env:"DB_CONNECTION_STRING"`
        DB                 DBObject        `json:"db"`
        Node               NodeObject      `json:"node" env:"NODE"`
        HeartbeatInterval  int             `json:"heartbeat_interval" env:"HEARTBEAT_INTERVAL"`
        HeartbeatBackoff   int             `json:"heartbeat_backoff" env:"HEARTBEAT_BACKOFF"`
        Reset              ResetObject     `json:"reset" env:"RESET"`
        FileStore          FileStoreObject `json:"file_store" env:"FILESTORE"`
        TLSEnabled         bool            `json:"tls_enabled" env:"TLS_ENABLED"`
        TLSSkipVerify      bool            `json:"tls_skip_verify" env:"TLS_SKIP_VERIFY"`
        TLSCrtPath         string          `json:"tls_crt_path" env:"TLS_CRT_PATH"`
        TLSKeyPath         string          `json:"tls_key_path" env:"TLS_KEY_PATH"`
}

type FileStoreObject struct {
        AccessKey string `json:"access_key"`
        SecretKey string `json:"secret_key"`
        Host      string `json:"host"`
        Port      int    `json:"port"`
        Bucket    string `json:"bucket"`
        Region    string `json:"region"`
        Protocol  string `json:"protocol"`
}

type UserObject struct {
        Username string `json:"username"`
        Password string `json:"password"`
        Email    string `json:"email"`
}

type DBObject struct {
        Protocol string `json:"protocol"`
        Username string `json:"username"`
        Password string `json:"password"`
        Name     string `json:"name"`
        Host     string `json:"host"`
        Port     int    `json:"port"`
}

type ResetObject struct {
        Email    string `json:"email"`
        Password string `json:"password"`
        Host     string `json:"mail_host"`
        Port     int    `json:"mail_port"`
}

type NodeObject struct {
        Type            string `json:"type"`
        ManagerHost     string `json:"manager_host"`
        ManagerPort     int    `json:"manager_port"`
        JoinKey         string `json:"join_key"`
        PrimaryKey      string `json:"primary_key"`
        ManagerProtocol string `json:"manager_protocol"`
}

var Config ConfigObject

func LoadConfig() <span class="cov2" title="2">{
        configPath := os.Getenv(ENV_PREFIX + "CONFIG_PATH")
        if configPath == "" </span><span class="cov2" title="2">{
                configPath = DEFAULT_CONFIG_PATH
        }</span>

        <span class="cov2" title="2">Config = ConfigObject{
                Host:              "",
                Port:              -1,
                Protocol:          "",
                BaseURL:           "http://localhost:2997",
                WSPort:            8080,
                LogLevel:          constants.LOG_LEVEL_INFO,
                LogFormat:         constants.LOG_FORMAT_CONSOLE,
                HeartbeatInterval: 500,
                HeartbeatBackoff:  10,
                TLSEnabled:        false,
                TLSSkipVerify:     false,
                TLSCrtPath:        "/tmp/cert.crt",
                TLSKeyPath:        "/tmp/cert.key",
                Admin: UserObject{
                        Username: "admin",
                        Password: "admin",
                },
                DBConnectionString: "mongodb://MyCoolMongoDBUsername:MyCoolMongoDBPassword@mongodb:27017/scaffold",
                DB:                 DBObject{},
                Reset: ResetObject{
                        Email:    "",
                        Password: "",
                        Host:     "smtp.gmail.com",
                        Port:     587,
                },
                Node: NodeObject{
                        Type:            "manager",
                        ManagerHost:     "scaffold-manager",
                        ManagerPort:     2997,
                        ManagerProtocol: "http",
                        JoinKey:         "MyCoolJoinKey12345",
                        PrimaryKey:      "MyCoolPrimaryKey12345",
                },
                FileStore: FileStoreObject{
                        AccessKey: "MyCoolMinIOAccessKey",
                        SecretKey: "MyCoolMinIOSecretKey",
                        Host:      "minio",
                        Port:      9000,
                        Bucket:    "scaffold",
                        Region:    "default-region",
                        Protocol:  "http",
                },
        }

        jsonFile, err := os.Open(configPath)
        if err == nil </span><span class="cov0" title="0">{
                log.Printf("Successfully Opened %v", configPath)

                byteValue, _ := ioutil.ReadAll(jsonFile)

                json.Unmarshal(byteValue, &amp;Config)
        }</span>

        <span class="cov2" title="2">v := reflect.ValueOf(Config)
        t := reflect.TypeOf(Config)

        for i := 0; i &lt; v.NumField(); i++ </span><span class="cov10" title="38">{
                field, found := t.FieldByName(v.Type().Field(i).Name)
                if !found </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov10" title="38">value := field.Tag.Get("env")
                if value != "" </span><span class="cov9" title="30">{
                        val, present := os.LookupEnv(ENV_PREFIX + value)
                        if present </span><span class="cov6" title="8">{
                                // log.Printf("Found ENV var %s with value %s", ENV_PREFIX+value, val)
                                w := reflect.ValueOf(&amp;Config).Elem().FieldByName(t.Field(i).Name)
                                x := getAttr(&amp;Config, t.Field(i).Name).Kind().String()
                                if w.IsValid() </span><span class="cov6" title="8">{
                                        switch x </span>{
                                        case "int", "int64":<span class="cov2" title="2">
                                                i, err := strconv.ParseInt(val, 10, 64)
                                                if err == nil </span><span class="cov2" title="2">{
                                                        w.SetInt(i)
                                                }</span>
                                        case "int8":<span class="cov0" title="0">
                                                i, err := strconv.ParseInt(val, 10, 8)
                                                if err == nil </span><span class="cov0" title="0">{
                                                        w.SetInt(i)
                                                }</span>
                                        case "int16":<span class="cov0" title="0">
                                                i, err := strconv.ParseInt(val, 10, 16)
                                                if err == nil </span><span class="cov0" title="0">{
                                                        w.SetInt(i)
                                                }</span>
                                        case "int32":<span class="cov0" title="0">
                                                i, err := strconv.ParseInt(val, 10, 32)
                                                if err == nil </span><span class="cov0" title="0">{
                                                        w.SetInt(i)
                                                }</span>
                                        case "string":<span class="cov2" title="2">
                                                w.SetString(val)</span>
                                        case "float32":<span class="cov0" title="0">
                                                i, err := strconv.ParseFloat(val, 32)
                                                if err == nil </span><span class="cov0" title="0">{
                                                        w.SetFloat(i)
                                                }</span>
                                        case "float", "float64":<span class="cov0" title="0">
                                                i, err := strconv.ParseFloat(val, 64)
                                                if err == nil </span><span class="cov0" title="0">{
                                                        w.SetFloat(i)
                                                }</span>
                                        case "bool":<span class="cov0" title="0">
                                                i, err := strconv.ParseBool(val)
                                                if err == nil </span><span class="cov0" title="0">{
                                                        w.SetBool(i)
                                                }</span>
                                        default:<span class="cov4" title="4">
                                                objValue := reflect.New(field.Type)
                                                objInterface := objValue.Interface()
                                                err := json.Unmarshal([]byte(val), objInterface)
                                                obj := reflect.ValueOf(objInterface)
                                                if err == nil </span><span class="cov4" title="4">{
                                                        w.Set(reflect.Indirect(obj).Convert(field.Type))
                                                }</span> else<span class="cov0" title="0"> {
                                                        log.Println(err)
                                                }</span>
                                        }
                                }
                        }
                }
        }

        // defer the closing of our jsonFile so that we can parse it later on
        <span class="cov2" title="2">defer jsonFile.Close()

        breakConfigFields()</span>
}

func getAttr(obj interface{}, fieldName string) reflect.Value <span class="cov6" title="8">{
        pointToStruct := reflect.ValueOf(obj) // addressable
        curStruct := pointToStruct.Elem()
        if curStruct.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                panic("not struct")</span>
        }
        <span class="cov6" title="8">curField := curStruct.FieldByName(fieldName) // type: reflect.Value
        if !curField.IsValid() </span><span class="cov0" title="0">{
                panic("not found:" + fieldName)</span>
        }
        <span class="cov6" title="8">return curField</span>
}

func breakConfigFields() <span class="cov2" title="2">{
        baseURL, err := url.Parse(Config.BaseURL)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov2" title="2">baseHost, basePortString, err := net.SplitHostPort(baseURL.Host)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov2" title="2">basePort, err := strconv.Atoi(basePortString)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov2" title="2">baseProtocol := baseURL.Scheme

        Config.Host = baseHost
        Config.Port = basePort
        Config.Protocol = baseProtocol

        mongoURL, err := url.Parse(Config.DBConnectionString)

        mongoHost, mongoPortString, err := net.SplitHostPort(baseURL.Host)
        mongoPort, err := strconv.Atoi(mongoPortString)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov2" title="2">mongoProtocol := baseURL.Scheme

        mongoUsername := mongoURL.User.Username()
        mongoPassword, isSet := mongoURL.User.Password()
        if !isSet </span><span class="cov0" title="0">{
                panic(errors.New("credentials not provided to DB connection string"))</span>
        }

        <span class="cov2" title="2">mongoName := mongoURL.Path[1:len(mongoURL.Path)]

        Config.DB.Host = mongoHost
        Config.DB.Port = mongoPort
        Config.DB.Username = mongoUsername
        Config.DB.Password = mongoPassword
        Config.DB.Name = mongoName
        Config.DB.Protocol = mongoProtocol</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package container

import (
        "fmt"
        "os"
        "os/exec"
        "scaffold/server/logger"
        "scaffold/server/run"
        "strings"
        "time"
)

var LastRun []string
var LastImage []string
var LastGroups [][]string
var CompletedRuns map[string]run.Run
var CurrentRun run.Run
var CurrentName string
var MaxAllowed = 10

func InitContainers() <span class="cov1" title="1">{
        LastRun = make([]string, 0)
        LastImage = make([]string, 0)
        LastGroups = make([][]string, 0)
        CurrentName = ""
}</span>

func PruneContainers() <span class="cov1" title="1">{
        for </span><span class="cov10" title="200">{
                for len(LastRun) &gt; MaxAllowed </span><span class="cov0" title="0">{
                        toDestroy := ""
                        toDestroy, LastRun = LastRun[0], LastRun[1:]
                        LastImage = LastImage[1:]
                        LastGroups = LastGroups[1:]

                        parts := strings.Split(toDestroy, ".")

                        containerName := fmt.Sprintf("%s-%s", parts[0], parts[1])
                        if containerName != CurrentName </span><span class="cov0" title="0">{
                                logs, err := exec.Command("/bin/sh", "-c", fmt.Sprintf("podman rm %s", containerName)).CombinedOutput()
                                if err != nil </span><span class="cov0" title="0">{
                                        logger.Errorf("", "Remove error string: %s", err.Error())
                                }</span>
                                <span class="cov0" title="0">logger.Debugf("", "Remove output: %s", logs)
                                runDir := fmt.Sprintf("/tmp/run/%s/%s/%s", parts[0], parts[1], parts[2])
                                if err := os.RemoveAll(runDir); err != nil </span><span class="cov0" title="0">{
                                        logger.Errorf("", "Delete error string: %s", err.Error())
                                }</span>
                        }
                }
                <span class="cov10" title="200">time.Sleep(250 * time.Millisecond)</span>
        }
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package datastore

import (
        "bytes"
        "encoding/json"
        "fmt"
        "net/http"
        "scaffold/server/config"
        "scaffold/server/constants"
        "scaffold/server/input"
        "scaffold/server/logger"
        "time"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"

        "scaffold/server/mongodb"
)

type DataStore struct {
        Name    string            `json:"name" bson:"name"`
        Env     map[string]string `json:"env" bson:"env"`
        Files   []string          `json:"files" bson:"files"`
        Created string            `json:"created" bson:"created"`
        Updated string            `json:"updated" bson:"updated"`
}

func CreateDataStore(d *DataStore) error <span class="cov5" title="6">{
        currentTime := time.Now().UTC()
        d.Created = currentTime.Format("2006-01-02T15:04:05Z")
        d.Updated = currentTime.Format("2006-01-02T15:04:05Z")

        if _, err := GetDataStoreByCascade(d.Name); err == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("datastore already exists with name %s", d.Name)
        }</span>

        <span class="cov5" title="6">_, err := mongodb.Collections[constants.MONGODB_DATASTORE_COLLECTION_NAME].InsertOne(mongodb.Ctx, d)
        return err</span>
}

func DeleteDataStoreByCascade(name string) error <span class="cov2" title="2">{
        filter := bson.M{"name": name}

        collection := mongodb.Collections[constants.MONGODB_DATASTORE_COLLECTION_NAME]
        ctx := mongodb.Ctx

        result, err := collection.DeleteOne(ctx, filter)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov2" title="2">if result.DeletedCount != 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("no datastore found with name %s", name)
        }</span>

        <span class="cov2" title="2">return nil</span>

}

func GetAllDataStores() ([]*DataStore, error) <span class="cov5" title="6">{
        filter := bson.D{{}}

        datastores, err := FilterDataStores(filter)

        return datastores, err
}</span>

func GetDataStoreByCascade(name string) (*DataStore, error) <span class="cov8" title="20">{
        filter := bson.M{"name": name}

        datastores, err := FilterDataStores(filter)

        if err != nil </span><span class="cov5" title="6">{
                return nil, err
        }</span>

        <span class="cov7" title="14">if len(datastores) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no datastore found with name %s", name)
        }</span>

        <span class="cov7" title="14">if len(datastores) &gt; 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("multiple datastores found with name %s", name)
        }</span>

        <span class="cov7" title="14">return datastores[0], nil</span>
}

func UpdateDataStoreByCascade(name string, d *DataStore, is []input.Input) error <span class="cov2" title="2">{
        filter := bson.M{"name": name}

        currentTime := time.Now().UTC()
        d.Updated = currentTime.Format("2006-01-02T15:04:05Z")

        if config.Config.Node.Type == constants.NODE_TYPE_MANAGER </span><span class="cov2" title="2">{
                logger.Infof("", "Node is of type %s", constants.NODE_TYPE_MANAGER)
                toChange := []string{}
                old, err := GetDataStoreByCascade(name)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("", "Error getting datastore %s: %s\n", name, err.Error())
                        return err
                }</span>

                <span class="cov2" title="2">for _, val := range is </span><span class="cov4" title="4">{
                        if old.Env[val.Name] != d.Env[val.Name] </span><span class="cov1" title="1">{
                                toChange = append(toChange, val.Name)
                        }</span>
                }
                <span class="cov2" title="2">postBody, _ := json.Marshal(toChange)
                postBodyBuffer := bytes.NewBuffer(postBody)

                httpClient := http.Client{}
                requestURL := fmt.Sprintf("%s://localhost:%d/api/v1/input/%s/update", config.Config.Protocol, config.Config.Port, d.Name)
                req, _ := http.NewRequest("POST", requestURL, postBodyBuffer)
                req.Header.Set("Authorization", fmt.Sprintf("X-Scaffold-API %s", config.Config.Node.PrimaryKey))
                resp, err := httpClient.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov2" title="2">if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                        return fmt.Errorf("received trigger status code %d", resp.StatusCode)
                }</span>
        }

        <span class="cov2" title="2">collection := mongodb.Collections[constants.MONGODB_DATASTORE_COLLECTION_NAME]
        ctx := mongodb.Ctx

        opts := options.Replace().SetUpsert(true)

        result, err := collection.ReplaceOne(ctx, filter, d, opts)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov2" title="2">if result.ModifiedCount != 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("no datastore found with name %s", name)
        }</span>

        <span class="cov2" title="2">return nil</span>
}

func FilterDataStores(filter interface{}) ([]*DataStore, error) <span class="cov9" title="26">{
        // A slice of tasks for storing the decoded documents
        var datastores []*DataStore

        collection := mongodb.Collections[constants.MONGODB_DATASTORE_COLLECTION_NAME]
        ctx := mongodb.Ctx

        cur, err := collection.Find(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return datastores, err
        }</span>

        <span class="cov9" title="26">for cur.Next(ctx) </span><span class="cov10" title="32">{
                var d DataStore
                err := cur.Decode(&amp;d)
                if err != nil </span><span class="cov0" title="0">{
                        return datastores, err
                }</span>

                <span class="cov10" title="32">datastores = append(datastores, &amp;d)</span>
        }

        <span class="cov9" title="26">if err := cur.Err(); err != nil </span><span class="cov0" title="0">{
                return datastores, err
        }</span>

        // once exhausted, close the cursor
        <span class="cov9" title="26">cur.Close(ctx)

        if len(datastores) == 0 </span><span class="cov5" title="6">{
                return datastores, mongo.ErrNoDocuments
        }</span>

        <span class="cov8" title="20">return datastores, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Code generated by swaggo/swag. DO NOT EDIT.

package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "termsOfService": "http://swagger.io/terms/",
        "contact": {
            "name": "John Carter",
            "url": "https://github.com/jfcarter2358/scaffold/issues",
            "email": "jfcarter2358@gmail.com"
        },
        "license": {
            "name": "MIT",
            "url": "https://opensource.org/license/mit/"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/api/v1/cascade": {
            "get": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Get all cascades",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "cascade"
                ],
                "summary": "Get all cascades",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/cascade.Cascade"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Create a cascade from a JSON object",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "cascade"
                ],
                "summary": "Create a cascade",
                "parameters": [
                    {
                        "description": "Cascade Data",
                        "name": "cascade",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/cascade.Cascade"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/cascade/{cascade_name}": {
            "get": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Get a cascade by its name",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "cascade"
                ],
                "summary": "Get a cascade",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/cascade.Cascade"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            },
            "put": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Update a cascade from a JSON object",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "cascade"
                ],
                "summary": "Update a cascade",
                "parameters": [
                    {
                        "description": "Cascade Data",
                        "name": "cascade",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/cascade.Cascade"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Delete a cascade by its name",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "cascade"
                ],
                "summary": "Delete a cascade",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/datastore": {
            "get": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Get all datastores",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "datastore"
                ],
                "summary": "Get all datastores",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/datastore.DataStore"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Create a datastore from a JSON object",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "datastore"
                ],
                "summary": "Create a datastore",
                "parameters": [
                    {
                        "description": "DataStore Data",
                        "name": "datastore",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/datastore.DataStore"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/datastore/{datastore_name}": {
            "get": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Get a datastore by its name",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "datastore"
                ],
                "summary": "Get a datastore",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/datastore.DataStore"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            },
            "put": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Update a datastore from a JSON object",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "datastore"
                ],
                "summary": "Update a datastore",
                "parameters": [
                    {
                        "description": "DataStore Data",
                        "name": "datastore",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/datastore.DataStore"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Delete a datastore by its name",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "datastore"
                ],
                "summary": "Delete a datastore",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/input": {
            "get": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Get all inputs",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "input"
                ],
                "summary": "Get all inputs",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/input.Input"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Create a input from a JSON object",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "input"
                ],
                "summary": "Create a input",
                "parameters": [
                    {
                        "description": "Input Data",
                        "name": "input",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/input.Input"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/input/{cascade_name}": {
            "get": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Get inputs by their cascade",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "input"
                ],
                "summary": "Get inputs",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/input.Input"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Delete inputs by their cascade",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "input"
                ],
                "summary": "Delete inputs",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/input/{cascade_name}/{input_name}": {
            "get": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Get a input by its name and its cascade",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "input"
                ],
                "summary": "Get a input",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/input.Input"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            },
            "put": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Update a input from a JSON object",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "input"
                ],
                "summary": "Update a input",
                "parameters": [
                    {
                        "description": "Input Data",
                        "name": "input",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/input.Input"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/input/{input_name}": {
            "delete": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Delete a input by its name and its cascade",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "input"
                ],
                "summary": "Delete a input",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/state": {
            "get": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Get all states",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "state"
                ],
                "summary": "Get all states",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/state.State"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Create a state from a JSON object",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "state"
                ],
                "summary": "Create a state",
                "parameters": [
                    {
                        "description": "State Data",
                        "name": "state",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/state.State"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/state/{cascade_name}": {
            "get": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Get states by their cascade",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "state"
                ],
                "summary": "Get states",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/state.State"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Delete states by their cascade",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "state"
                ],
                "summary": "Delete states",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/state/{cascade_name}/{state_name}": {
            "get": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Get a state by its name and its cascade",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "state"
                ],
                "summary": "Get a state",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/state.State"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            },
            "put": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Update a state from a JSON object",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "state"
                ],
                "summary": "Update a state",
                "parameters": [
                    {
                        "description": "State Data",
                        "name": "state",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/state.State"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Delete a state by its name and its cascade",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "state"
                ],
                "summary": "Delete a state",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/task": {
            "get": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Get all tasks",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "task"
                ],
                "summary": "Get all tasks",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/task.Task"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Create a task from a JSON object",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "task"
                ],
                "summary": "Create a task",
                "parameters": [
                    {
                        "description": "Task Data",
                        "name": "task",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/task.Task"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/task/{cascade_name}": {
            "get": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Get tasks by their cascade",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "task"
                ],
                "summary": "Get tasks",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/task.Task"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Delete tasks by their cascade",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "task"
                ],
                "summary": "Delete tasks",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/task/{cascade_name}/{task_name}": {
            "get": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Get a task by its name and its cascade",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "task"
                ],
                "summary": "Get a task",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/task.Task"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            },
            "put": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Update a task from a JSON object",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "task"
                ],
                "summary": "Update a task",
                "parameters": [
                    {
                        "description": "Task Data",
                        "name": "task",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/task.Task"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/task/{task_name}": {
            "delete": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Delete a task by its name and its cascade",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "task"
                ],
                "summary": "Delete a task",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/user": {
            "get": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Get all users",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "user"
                ],
                "summary": "Get all users",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/user.User"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Create a user from a JSON object",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "user"
                ],
                "summary": "Create a user",
                "parameters": [
                    {
                        "description": "User Data",
                        "name": "user",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/user.User"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/user/{user_name}": {
            "put": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Update a user from a JSON object",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "user"
                ],
                "summary": "Update a user",
                "parameters": [
                    {
                        "description": "User Data",
                        "name": "user",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/user.User"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/user/{username}": {
            "get": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Get a user by its username",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "user"
                ],
                "summary": "Get a user",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/user.User"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Delete a user by its username",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "user"
                ],
                "summary": "Delete a user",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/auth/token/{username}/{token_name}": {
            "post": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Generate an API token for a user",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "user"
                ],
                "summary": "Generate API Token",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "object"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Revoke an API token for a user",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "user"
                ],
                "summary": "Revoke API Token",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "object"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/health/available": {
            "get": {
                "description": "Get status from node succeeding if not containers are running",
                "tags": [
                    "worker",
                    "health"
                ],
                "summary": "Check if a worker node is available",
                "responses": {
                    "200": {
                        "description": "OK"
                    },
                    "503": {
                        "description": "Service Unavailable"
                    }
                }
            }
        },
        "/health/healthy": {
            "get": {
                "description": "Get node health",
                "tags": [
                    "manager",
                    "worker",
                    "health"
                ],
                "summary": "Check if a node is healthy",
                "responses": {
                    "200": {
                        "description": "OK"
                    },
                    "503": {
                        "description": "Service Unavailable"
                    }
                }
            }
        },
        "/health/ready": {
            "get": {
                "description": "Get node readiness",
                "tags": [
                    "manager",
                    "worker",
                    "health"
                ],
                "summary": "Check if a node is ready",
                "responses": {
                    "200": {
                        "description": "OK"
                    },
                    "503": {
                        "description": "Service Unavailable"
                    }
                }
            }
        },
        "/health/status": {
            "get": {
                "description": "Get status from all nodes",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "health"
                ],
                "summary": "Get status of all nodes",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "cascade.Cascade": {
            "type": "object",
            "properties": {
                "created": {
                    "type": "string"
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "inputs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/input.Input"
                    }
                },
                "links": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "name": {
                    "type": "string"
                },
                "tasks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/task.Task"
                    }
                },
                "updated": {
                    "type": "string"
                },
                "version": {
                    "type": "string"
                }
            }
        },
        "datastore.DataStore": {
            "type": "object",
            "properties": {
                "created": {
                    "type": "string"
                },
                "env": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "files": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "name": {
                    "type": "string"
                },
                "updated": {
                    "type": "string"
                }
            }
        },
        "input.Input": {
            "type": "object",
            "properties": {
                "cascade": {
                    "type": "string"
                },
                "default": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "type": {
                    "type": "string"
                }
            }
        },
        "state.State": {
            "type": "object",
            "properties": {
                "cascade": {
                    "type": "string"
                },
                "display": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "additionalProperties": true
                    }
                },
                "finished": {
                    "type": "string"
                },
                "number": {
                    "type": "integer"
                },
                "output": {
                    "type": "string"
                },
                "started": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                },
                "task": {
                    "type": "string"
                }
            }
        },
        "task.Task": {
            "type": "object",
            "properties": {
                "auto_execute": {
                    "type": "boolean"
                },
                "cascade": {
                    "type": "string"
                },
                "check": {
                    "$ref": "#/definitions/task.TaskCheck"
                },
                "depends_on": {
                    "$ref": "#/definitions/task.TaskDependsOn"
                },
                "env": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "image": {
                    "type": "string"
                },
                "inputs": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "load": {
                    "$ref": "#/definitions/task.TaskLoadStore"
                },
                "name": {
                    "type": "string"
                },
                "run": {
                    "type": "string"
                },
                "run_number": {
                    "type": "integer"
                },
                "should_rm": {
                    "type": "boolean"
                },
                "store": {
                    "$ref": "#/definitions/task.TaskLoadStore"
                },
                "updated": {
                    "type": "string"
                }
            }
        },
        "task.TaskCheck": {
            "type": "object",
            "properties": {
                "env": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "image": {
                    "type": "string"
                },
                "inputs": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "interval": {
                    "type": "integer"
                },
                "load": {
                    "$ref": "#/definitions/task.TaskLoadStore"
                },
                "run": {
                    "type": "string"
                },
                "run_number": {
                    "type": "integer"
                },
                "store": {
                    "$ref": "#/definitions/task.TaskLoadStore"
                },
                "updated": {
                    "type": "string"
                }
            }
        },
        "task.TaskDependsOn": {
            "type": "object",
            "properties": {
                "always": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "error": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "success": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "task.TaskLoadStore": {
            "type": "object",
            "properties": {
                "env": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "file": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "user.APIToken": {
            "type": "object",
            "properties": {
                "created": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "token": {
                    "type": "string"
                }
            }
        },
        "user.User": {
            "type": "object",
            "properties": {
                "api_tokens": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/user.APIToken"
                    }
                },
                "created": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "family_name": {
                    "type": "string"
                },
                "given_name": {
                    "type": "string"
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "login_token": {
                    "type": "string"
                },
                "password": {
                    "type": "string"
                },
                "reset_token": {
                    "type": "string"
                },
                "reset_token_created": {
                    "type": "string"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "updated": {
                    "type": "string"
                },
                "username": {
                    "type": "string"
                }
            }
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "2.0",
        Host:             "",
        BasePath:         "",
        Schemes:          []string{},
        Title:            "Scaffold Swagger API",
        Description:      "Scaffold workflow tool",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov10" title="2">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package filestore

import (
        "fmt"
        "os"
        "scaffold/server/config"
        "scaffold/server/logger"

        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/aws/credentials"
        "github.com/aws/aws-sdk-go/aws/session"
        "github.com/aws/aws-sdk-go/service/s3"
        "github.com/aws/aws-sdk-go/service/s3/s3manager"
)

var S3Config *aws.Config

type ObjectMetadata struct {
        Name     string `json:"name" bson:"name"`
        Modified string `json:"modified" bson:"modified"`
        Cascade  string `json:"cascade" bson:"cascade"`
}

func InitBucket() <span class="cov10" title="2">{
        bucket := aws.String(config.Config.FileStore.Bucket)

        // Configure to use MinIO Server
        var S3Config *aws.Config
        if config.Config.FileStore.AccessKey != "" &amp;&amp; config.Config.FileStore.SecretKey != "" {
                S3Config = &amp;aws.Config{
                        Credentials:      credentials.NewStaticCredentials(config.Config.FileStore.AccessKey, config.Config.FileStore.SecretKey, ""),
                        Endpoint:         aws.String(fmt.Sprintf("%s://%s:%d", config.Config.FileStore.Protocol, config.Config.FileStore.Host, config.Config.FileStore.Port)),
                        Region:           aws.String(config.Config.FileStore.Region),
                        DisableSSL:       aws.Bool(false),
                        S3ForcePathStyle: aws.Bool(true),
                }
</span>        } else {
</span>                S3Config = &amp;aws.Config{
                        Endpoint:         aws.String(fmt.Sprintf("%s://%s:%d", config.Config.FileStore.Protocol, config.Config.FileStore.Host, config.Config.FileStore.Port)),
        <span class="cov10" title="2">                Region:           aws.String(config.Config.FileStore.Region),
                        DisableSSL:       aws.Bool(false),
                        S3ForcePathStyle: aws.Bool(true),
                }
        }
        session, err := session.NewSession(S3Config)
        if err != nil {
                panic(err)
</span>        }
</span>
        client := s3.New(session)

        cparams := &amp;s3.CreateBucketInput{
</span>                Bucket: bucket, // Required
</span>        }

</span>        buckets, err := client.ListBuckets(nil)
        if err != nil {
                panic(err)
        <span class="cov10" title="2">}
</span>
        alreadyExists := false
        for _, bucket :</span><span class="cov0" title="0">= range buckets.Buckets {
                if *bucket.Name == config.Config.FileStore.Bucket {
                        alreadyExists = true
                        </span>break
                }
        }

        if !alreadyExists {
                // Create a new bucket using the CreateBucket call.
                _, err := cli</span><span class="cov0" title="0">ent.CreateBucket(cparams)
                if err != </span>nil {
                        logger.Errorf("", "Encountered error with creating bucket: %v", err)
        <span class="cov0" title="0">                // panic(err)
                }
        }
</span>}

</span>func GetFile(inputPath, outputPath string) error {
        <span class="cov0" title="0">session, err := session.NewSession(S3Config)
        if err != nil {
                panic(err)
        }
        downloader := s3manager.NewDownloader(session)
        file, err := os.Create(outputPath)
        if err != nil {
                return err
        }

        defer file</span>.Close()

        _, err = downloader.Download(
                file,
                &amp;s3.GetObjectInput{
                        Bucket: aws.</span><span class="cov0" title="0">String(config.Config.FileStore.Bucket),
                        Key:    a</span>ws.String(inputPath),
                },
        <span class="cov0" title="0">)

        return err
</span>}

</span>func UploadFile(inputPath, outputPath string) error {
        <span class="cov0" title="0">session, err := session.NewSession(S3Config)
        if err != nil {
                panic(err)
        }
        uploader := s3manager.NewUploader(session)
        file, err := os.Open(inputPath)
        if err != nil {
                return err
        }
</span>
        defer file.Close()

        _, err = uploader.Upload(&amp;s3manager.UploadInput{
                Bucket: aws.S</span><span class="cov0" title="0">tring(config.Config.FileStore.Bucket),
                Key:    aw</span>s.String(outputPath),
                Body:   file,
        <span class="cov0" title="0">})

        return err
}
</span>
fu</span>nc ListObjects() (map[string]ObjectMetadata, error) {
        session, err := session.NewSession(S3Config)
        <span class="cov0" title="0">if err != nil {
                panic(err)
        }
</span>        svc := s3.New(session)

        resp, err := svc.ListObjectsV2(&amp;s3.ListObjectsV2Input{Bucket: aws.String(config.Config.FileStore.Bucket)})
        if err != nil {
                </span>return map[string]ObjectMetadata{}, err
        <span class="cov0" title="0">}
</span>
        output := make(map[string]ObjectMetadata)

        for _, item := range resp.Contents {
                output[*item.Key] = ObjectMetadata{
                        Name:     *item.Key,
                        Modified: (*item.LastModified).Format("2006-01-02T15:04:05Z"),
                }
        }
        return output, nil
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package input

import (
        "fmt"
        "scaffold/server/constants"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"

        "scaffold/server/mongodb"
)

type Input struct {
        Name        string `json:"name" bson:"name"`
        Cascade     string `json:"cascade" bson:"cascade"`
        Description string `json:"description" bson:"description"`
        Default     string `json:"default" bson:"default"`
        Type        string `json:"type" bson:"type"`
}

func CreateInput(i *Input) error <span class="cov9" title="11">{
        if _, err := GetInputByNames(i.Cascade, i.Name); err == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("input already exists with names %s, %s", i.Cascade, i.Name)
        }</span>

        <span class="cov9" title="11">_, err := mongodb.Collections[constants.MONGODB_INPUT_COLLECTION_NAME].InsertOne(mongodb.Ctx, i)
        return err</span>
}

func DeleteInputByNames(cascade, name string) error <span class="cov1" title="1">{
        filter := bson.M{"cascade": cascade, "name": name}

        collection := mongodb.Collections[constants.MONGODB_INPUT_COLLECTION_NAME]
        ctx := mongodb.Ctx

        result, err := collection.DeleteOne(ctx, filter)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">if result.DeletedCount != 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("no input found with names %s, %s", cascade, name)
        }</span>

        <span class="cov1" title="1">return nil</span>

}

func DeleteInputsByCascade(cascade string) error <span class="cov3" title="2">{
        filter := bson.M{"cascade": cascade}

        collection := mongodb.Collections[constants.MONGODB_INPUT_COLLECTION_NAME]
        ctx := mongodb.Ctx

        result, err := collection.DeleteMany(ctx, filter)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="2">if result.DeletedCount == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no inputs found with cascade %s", cascade)
        }</span>

        <span class="cov3" title="2">return nil</span>

}

func GetAllInputs() ([]*Input, error) <span class="cov1" title="1">{
        filter := bson.D{{}}

        inputs, err := FilterInputs(filter)

        return inputs, err
}</span>

func GetInputByNames(cascade, name string) (*Input, error) <span class="cov9" title="12">{
        filter := bson.M{"cascade": cascade, "name": name}

        inputs, err := FilterInputs(filter)

        if err != nil </span><span class="cov9" title="11">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if len(inputs) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no input found with names %s, %s", cascade, name)
        }</span>

        <span class="cov1" title="1">if len(inputs) &gt; 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("multiple inputs found with names %s, %s", cascade, name)
        }</span>

        <span class="cov1" title="1">return inputs[0], nil</span>
}

func GetInputsByCascade(cascade string) ([]*Input, error) <span class="cov1" title="1">{
        filter := bson.M{"cascade": cascade}

        inputs, err := FilterInputs(filter)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return inputs, nil</span>
}

func UpdateInputByNames(cascade, name string, i *Input) error <span class="cov1" title="1">{
        filter := bson.M{"cascade": cascade, "name": name}

        collection := mongodb.Collections[constants.MONGODB_INPUT_COLLECTION_NAME]
        ctx := mongodb.Ctx

        opts := options.Replace().SetUpsert(true)

        result, err := collection.ReplaceOne(ctx, filter, i, opts)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">if result.ModifiedCount != 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("no input found with names %s, %s", cascade, name)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func FilterInputs(filter interface{}) ([]*Input, error) <span class="cov10" title="14">{
        // A slice of inputs for storing the decoded documents
        var inputs []*Input

        collection := mongodb.Collections[constants.MONGODB_INPUT_COLLECTION_NAME]
        ctx := mongodb.Ctx

        cur, err := collection.Find(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return inputs, err
        }</span>

        <span class="cov10" title="14">for cur.Next(ctx) </span><span class="cov8" title="10">{
                var s Input
                err := cur.Decode(&amp;s)
                if err != nil </span><span class="cov0" title="0">{
                        return inputs, err
                }</span>

                <span class="cov8" title="10">inputs = append(inputs, &amp;s)</span>
        }

        <span class="cov10" title="14">if err := cur.Err(); err != nil </span><span class="cov0" title="0">{
                return inputs, err
        }</span>

        // once exhausted, close the cursor
        <span class="cov10" title="14">cur.Close(ctx)

        if len(inputs) == 0 </span><span class="cov9" title="11">{
                return inputs, mongo.ErrNoDocuments
        }</span>

        <span class="cov4" title="3">return inputs, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package logger

import (
        "encoding/json"
        "fmt"
        "os"
        "scaffold/server/constants"
        "time"

        "github.com/gin-gonic/gin"
)

var LogLevel = 0
var LogFormat = constants.LOG_FORMAT_CONSOLE

var ConsoleLogFormatter = func(param gin.LogFormatterParams) string <span class="cov8" title="295">{
        if param.Latency &gt; time.Minute </span><span class="cov0" title="0">{
                param.Latency = param.Latency.Truncate(time.Second)
        }</span>

        <span class="cov8" title="295">timestamp := param.TimeStamp.Format("2006-01-02T15:04:05Z")
        statusCode := param.StatusCode
        latency := param.Latency
        clientIP := param.ClientIP
        method := param.Method
        path := param.Path
        errorMessage := param.ErrorMessage

        statusCodeColor := constants.COLOR_GREEN
        methodColor := constants.COLOR_MAGENTA

        level := constants.LOG_LEVEL_INFO
        if statusCode &gt;= 400 </span><span class="cov6" title="70">{
                level = constants.LOG_LEVEL_ERROR
                statusCodeColor = constants.COLOR_RED
        }</span>

        <span class="cov8" title="295">switch method </span>{
        case "GET":<span class="cov8" title="248">
                methodColor = constants.METHOD_GET</span>
        case "POST":<span class="cov5" title="32">
                methodColor = constants.METHOD_POST</span>
        case "PUT":<span class="cov3" title="7">
                methodColor = constants.METHOD_PUT</span>
        case "PATCH":<span class="cov0" title="0">
                methodColor = constants.METHOD_PATCH</span>
        case "DELETE":<span class="cov3" title="8">
                methodColor = constants.METHOD_DELETE</span>
        }

        <span class="cov8" title="295">return Logf(level,
                constants.LOG_FORMAT_CONSOLE,
                timestamp,
                "%s%3d%s | %13v | %15s | %s%-7s%s %#v | %s",
                statusCodeColor,
                statusCode,
                constants.COLOR_NONE,
                latency,
                clientIP,
                methodColor,
                method,
                constants.COLOR_NONE,
                path,
                errorMessage,
        )</span>
}

var JSONLogFormatter = func(param gin.LogFormatterParams) string <span class="cov0" title="0">{
        if param.Latency &gt; time.Minute </span><span class="cov0" title="0">{
                param.Latency = param.Latency.Truncate(time.Second)
        }</span>

        <span class="cov0" title="0">timestamp := param.TimeStamp.Format("2006-01-02T15:04:05Z")
        statusCode := param.StatusCode
        latency := param.Latency
        clientIP := param.ClientIP
        method := param.Method
        path := param.Path
        errorMessage := param.ErrorMessage

        statusCodeColor := constants.COLOR_GREEN
        methodColor := constants.COLOR_MAGENTA

        level := constants.LOG_LEVEL_INFO
        if statusCode &gt;= 400 </span><span class="cov0" title="0">{
                level = constants.LOG_LEVEL_ERROR
                statusCodeColor = constants.COLOR_RED
        }</span>

        <span class="cov0" title="0">switch method </span>{
        case "GET":<span class="cov0" title="0">
                methodColor = constants.METHOD_GET</span>
        case "POST":<span class="cov0" title="0">
                methodColor = constants.METHOD_POST</span>
        case "PUT":<span class="cov0" title="0">
                methodColor = constants.METHOD_PUT</span>
        case "PATCH":<span class="cov0" title="0">
                methodColor = constants.METHOD_PATCH</span>
        case "DELETE":<span class="cov0" title="0">
                methodColor = constants.METHOD_DELETE</span>
        }

        <span class="cov0" title="0">return Logf(level,
                constants.LOG_FORMAT_CONSOLE,
                timestamp,
                "%s%3d%s | %13v | %15s | %s%-7s%s %#v | %s",
                statusCodeColor,
                statusCode,
                constants.COLOR_NONE,
                latency,
                clientIP,
                methodColor,
                method,
                constants.COLOR_NONE,
                path,
                errorMessage,
        )</span>
}

func sliceIndex(list []string, val string) int <span class="cov2" title="4">{
        for i := 0; i &lt; len(list); i++ </span><span class="cov4" title="14">{
                if list[i] == val </span><span class="cov2" title="4">{
                        return i
                }</span>
        }
        <span class="cov0" title="0">return -1</span>
}

func SetLevel(level string) <span class="cov1" title="2">{
        levels := []string{constants.LOG_LEVEL_NONE, constants.LOG_LEVEL_FATAL, constants.LOG_LEVEL_SUCCESS, constants.LOG_LEVEL_ERROR, constants.LOG_LEVEL_WARN, constants.LOG_LEVEL_INFO, constants.LOG_LEVEL_DEBUG, constants.LOG_LEVEL_TRACE}
        levelInt := sliceIndex(levels, level)
        if levelInt == -1 </span><span class="cov0" title="0">{
                Fatalf("Unknown log level %s", level)
        }</span>
        <span class="cov1" title="2">LogLevel = levelInt</span>
}

func SetFormat(format string) <span class="cov1" title="2">{
        formats := []string{constants.LOG_FORMAT_CONSOLE, constants.LOG_FORMAT_JSON}
        formatInt := sliceIndex(formats, format)
        if formatInt == -1 </span><span class="cov0" title="0">{
                Fatalf("Unknown log level %s", format)
        }</span>
        <span class="cov1" title="2">LogFormat = format</span>
}

func Logf(level, formatter, timestamp, format string, args ...interface{}) string <span class="cov10" title="911">{
        if formatter == constants.LOG_FORMAT_JSON </span><span class="cov0" title="0">{
                log := map[string]interface{}{
                        "level":     level,
                        "timestamp": timestamp,
                        "message":   fmt.Sprintf(format, args...),
                }
                logBytes, _ := json.Marshal(&amp;log)
                return string(logBytes)
        }</span>
        <span class="cov10" title="911">switch level </span>{
        case constants.LOG_LEVEL_DEBUG:<span class="cov0" title="0">
                return Sdebugf(timestamp, format, args...)</span>
        case constants.LOG_LEVEL_ERROR:<span class="cov7" title="94">
                return Serrorf(timestamp, format, args...)</span>
        case constants.LOG_LEVEL_FATAL:<span class="cov0" title="0">
                return Sfatalf(timestamp, format, args...)</span>
        case constants.LOG_LEVEL_INFO:<span class="cov9" title="817">
                return Sinfof(timestamp, format, args...)</span>
        case constants.LOG_LEVEL_SUCCESS:<span class="cov0" title="0">
                return Ssuccessf(timestamp, format, args...)</span>
        case constants.LOG_LEVEL_TRACE:<span class="cov0" title="0">
                return Stracef(timestamp, format, args...)</span>
        case constants.LOG_LEVEL_WARN:<span class="cov0" title="0">
                return Swarnf(timestamp, format, args...)</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func Debug(timestamp, message string) <span class="cov0" title="0">{
        if LogLevel &gt;= constants.LOG_LEVEL_DEBUG_NUM </span><span class="cov0" title="0">{
                if timestamp == "" </span><span class="cov0" title="0">{
                        timestamp = time.Now().UTC().Format("2006-01-02T15:04:05Z")
                }</span>
                <span class="cov0" title="0">fmt.Print(Logf(constants.LOG_LEVEL_DEBUG, LogFormat, timestamp, message))</span>
                // fmt.Printf("%s[DEBUG  ]%s [%s] :: %s\n", constants.COLOR_CYAN, constants.COLOR_NONE, timestamp, message)
        }
}

func Debugf(timestamp, format string, args ...interface{}) <span class="cov8" title="229">{
        if LogLevel &gt;= constants.LOG_LEVEL_DEBUG_NUM </span><span class="cov0" title="0">{
                if timestamp == "" </span><span class="cov0" title="0">{
                        timestamp = time.Now().UTC().Format("2006-01-02T15:04:05Z")
                }</span>
                <span class="cov0" title="0">fmt.Print(Logf(constants.LOG_LEVEL_DEBUG, LogFormat, timestamp, format, args...))</span>
                // fmt.Printf("%s[DEBUG  ]%s [%s] :: %s\n", constants.COLOR_CYAN, constants.COLOR_NONE, timestamp, fmt.Sprintf(format, args...))
        }
}

func Sdebugf(timestamp, format string, args ...interface{}) string <span class="cov0" title="0">{
        if LogLevel &gt;= constants.LOG_LEVEL_DEBUG_NUM </span><span class="cov0" title="0">{
                if timestamp == "" </span><span class="cov0" title="0">{
                        timestamp = time.Now().UTC().Format("2006-01-02T15:04:05Z")
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("%s[DEBUG  ]%s [%s] :: %s\n", constants.COLOR_CYAN, constants.COLOR_NONE, timestamp, fmt.Sprintf(format, args...))</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func Error(timestamp, message string) <span class="cov3" title="6">{
        if LogLevel &gt;= constants.LOG_LEVEL_ERROR_NUM </span><span class="cov3" title="6">{
                if timestamp == "" </span><span class="cov3" title="6">{
                        timestamp = time.Now().UTC().Format("2006-01-02T15:04:05Z")
                }</span>
                <span class="cov3" title="6">fmt.Print(Logf(constants.LOG_LEVEL_ERROR, LogFormat, timestamp, message))</span>
                // fmt.Printf("%s[ERROR  ]%s [%s] :: %s\n", constants.COLOR_RED, constants.COLOR_NONE, timestamp, message)
        }
}

func Errorf(timestamp, format string, args ...interface{}) <span class="cov4" title="18">{
        if LogLevel &gt;= constants.LOG_LEVEL_ERROR_NUM </span><span class="cov4" title="18">{
                if timestamp == "" </span><span class="cov4" title="18">{
                        timestamp = time.Now().UTC().Format("2006-01-02T15:04:05Z")
                }</span>
                <span class="cov4" title="18">fmt.Print(Logf(constants.LOG_LEVEL_ERROR, LogFormat, timestamp, format, args...))</span>
                // fmt.Printf("%s[ERROR  ]%s [%s] :: %s\n", constants.COLOR_RED, constants.COLOR_NONE, timestamp, fmt.Sprintf(format, args...))
        }
}

func Serrorf(timestamp, format string, args ...interface{}) string <span class="cov7" title="94">{
        if LogLevel &gt;= constants.LOG_LEVEL_ERROR_NUM </span><span class="cov7" title="94">{
                if timestamp == "" </span><span class="cov0" title="0">{
                        timestamp = time.Now().UTC().Format("2006-01-02T15:04:05Z")
                }</span>
                <span class="cov7" title="94">return fmt.Sprintf("%s[ERROR  ]%s [%s] :: %s\n", constants.COLOR_RED, constants.COLOR_NONE, timestamp, fmt.Sprintf(format, args...))</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func Fatal(timestamp, message string) <span class="cov0" title="0">{
        if LogLevel &gt;= constants.LOG_LEVEL_FATAL_NUM </span><span class="cov0" title="0">{
                if timestamp == "" </span><span class="cov0" title="0">{
                        timestamp = time.Now().UTC().Format("2006-01-02T15:04:05Z")
                }</span>
                <span class="cov0" title="0">fmt.Print(Logf(constants.LOG_LEVEL_FATAL, LogFormat, timestamp, message))
                // fmt.Printf("%s[FATAL  ]%s [%s] :: %s\n", constants.COLOR_RED, constants.COLOR_NONE, timestamp, message)
                os.Exit(1)</span>
        }
}

func Fatalf(timestamp, format string, args ...interface{}) <span class="cov0" title="0">{
        if LogLevel &gt;= constants.LOG_LEVEL_FATAL_NUM </span><span class="cov0" title="0">{
                if timestamp == "" </span><span class="cov0" title="0">{
                        timestamp = time.Now().UTC().Format("2006-01-02T15:04:05Z")
                }</span>
                <span class="cov0" title="0">fmt.Print(Logf(constants.LOG_LEVEL_FATAL, LogFormat, timestamp, format, args...))
                // fmt.Printf("%s[FATAL  ]%s [%s] :: %s\n", constants.COLOR_RED, constants.COLOR_NONE, timestamp, fmt.Sprintf(format, args...))
                os.Exit(1)</span>
        }
}

func Sfatalf(timestamp, format string, args ...interface{}) string <span class="cov0" title="0">{
        if LogLevel &gt;= constants.LOG_LEVEL_FATAL_NUM </span><span class="cov0" title="0">{
                if timestamp == "" </span><span class="cov0" title="0">{
                        timestamp = time.Now().UTC().Format("2006-01-02T15:04:05Z")
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("%s[FATAL  ]%s [%s] :: %s\n", constants.COLOR_RED, constants.COLOR_NONE, timestamp, fmt.Sprintf(format, args...))</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func Info(timestamp, message string) <span class="cov1" title="1">{
        if LogLevel &gt;= constants.LOG_LEVEL_INFO_NUM </span><span class="cov1" title="1">{
                if timestamp == "" </span><span class="cov1" title="1">{
                        timestamp = time.Now().UTC().Format("2006-01-02T15:04:05Z")
                }</span>
                <span class="cov1" title="1">fmt.Print(Logf(constants.LOG_LEVEL_INFO, LogFormat, timestamp, message))</span>
                // fmt.Printf("%s[INFO   ]%s [%s] :: %s\n", constants.COLOR_GREEN, constants.COLOR_NONE, timestamp, message)
        }
}

func Infof(timestamp, format string, args ...interface{}) <span class="cov9" title="591">{
        if LogLevel &gt;= constants.LOG_LEVEL_INFO_NUM </span><span class="cov9" title="591">{
                if timestamp == "" </span><span class="cov9" title="591">{
                        timestamp = time.Now().UTC().Format("2006-01-02T15:04:05Z")
                }</span>
                <span class="cov9" title="591">fmt.Print(Logf(constants.LOG_LEVEL_INFO, LogFormat, timestamp, format, args...))</span>
                // fmt.Printf("%s[INFO   ]%s [%s] :: %s\n", constants.COLOR_GREEN, constants.COLOR_NONE, timestamp, fmt.Sprintf(format, args...))
        }
}

func Sinfof(timestamp, format string, args ...interface{}) string <span class="cov9" title="817">{
        if LogLevel &gt;= constants.LOG_LEVEL_INFO_NUM </span><span class="cov9" title="817">{
                if timestamp == "" </span><span class="cov0" title="0">{
                        timestamp = time.Now().UTC().Format("2006-01-02T15:04:05Z")
                }</span>
                <span class="cov9" title="817">return fmt.Sprintf("%s[INFO   ]%s [%s] :: %s\n", constants.COLOR_GREEN, constants.COLOR_NONE, timestamp, fmt.Sprintf(format, args...))</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func Success(timestamp, message string) <span class="cov0" title="0">{
        if LogLevel &gt;= constants.LOG_LEVEL_SUCCESS_NUM </span><span class="cov0" title="0">{
                if timestamp == "" </span><span class="cov0" title="0">{
                        timestamp = time.Now().UTC().Format("2006-01-02T15:04:05Z")
                }</span>
                <span class="cov0" title="0">fmt.Print(Logf(constants.LOG_LEVEL_SUCCESS, LogFormat, timestamp, message))</span>
                // fmt.Printf("%s[SUCCESS]%s [%s] :: %s\n", constants.COLOR_GREEN, constants.COLOR_NONE, timestamp, message)
        }
}

func Successf(timestamp, format string, args ...interface{}) <span class="cov0" title="0">{
        if LogLevel &gt;= constants.LOG_LEVEL_SUCCESS_NUM </span><span class="cov0" title="0">{
                if timestamp == "" </span><span class="cov0" title="0">{
                        timestamp = time.Now().UTC().Format("2006-01-02T15:04:05Z")
                }</span>
                <span class="cov0" title="0">fmt.Print(Logf(constants.LOG_LEVEL_SUCCESS, LogFormat, timestamp, format, args...))</span>
                // fmt.Printf("%s[SUCCESS]%s [%s] :: %s\n", constants.COLOR_GREEN, constants.COLOR_NONE, timestamp, fmt.Sprintf(format, args...))
        }
}

func Ssuccessf(timestamp, format string, args ...interface{}) string <span class="cov0" title="0">{
        if LogLevel &gt;= constants.LOG_LEVEL_SUCCESS_NUM </span><span class="cov0" title="0">{
                if timestamp == "" </span><span class="cov0" title="0">{
                        timestamp = time.Now().UTC().Format("2006-01-02T15:04:05Z")
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("%s[SUCCESS]%s [%s] :: %s\n", constants.COLOR_GREEN, constants.COLOR_NONE, timestamp, fmt.Sprintf(format, args...))</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func Trace(timestamp, message string) <span class="cov0" title="0">{
        if LogLevel &gt;= constants.LOG_LEVEL_TRACE_NUM </span><span class="cov0" title="0">{
                if timestamp == "" </span><span class="cov0" title="0">{
                        timestamp = time.Now().UTC().Format("2006-01-02T15:04:05Z")
                }</span>
                <span class="cov0" title="0">fmt.Print(Logf(constants.LOG_LEVEL_TRACE, LogFormat, timestamp, message))</span>
                // fmt.Printf("%s[TRACE  ]%s [%s] :: %s\n", constants.COLOR_BLUE, constants.COLOR_NONE, timestamp, message)
        }
}

func Tracef(timestamp, format string, args ...interface{}) <span class="cov0" title="0">{
        if LogLevel &gt;= constants.LOG_LEVEL_TRACE_NUM </span><span class="cov0" title="0">{
                if timestamp == "" </span><span class="cov0" title="0">{
                        timestamp = time.Now().UTC().Format("2006-01-02T15:04:05Z")
                }</span>
                <span class="cov0" title="0">fmt.Print(Logf(constants.LOG_LEVEL_TRACE, LogFormat, timestamp, format, args...))</span>
                // fmt.Printf("%s[TRACE  ]%s [%s] :: %s\n", constants.COLOR_BLUE, constants.COLOR_NONE, timestamp, fmt.Sprintf(format, args...))
        }
}

func Stracef(timestamp, format string, args ...interface{}) string <span class="cov0" title="0">{
        if LogLevel &gt;= constants.LOG_LEVEL_TRACE_NUM </span><span class="cov0" title="0">{
                if timestamp == "" </span><span class="cov0" title="0">{
                        timestamp = time.Now().UTC().Format("2006-01-02T15:04:05Z")
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("%s[TRACE  ]%s [%s] :: %s\n", constants.COLOR_BLUE, constants.COLOR_NONE, timestamp, fmt.Sprintf(format, args...))</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func Warn(timestamp, message string) <span class="cov0" title="0">{
        if LogLevel &gt;= constants.LOG_LEVEL_WARN_NUM </span><span class="cov0" title="0">{
                if timestamp == "" </span><span class="cov0" title="0">{
                        timestamp = time.Now().UTC().Format("2006-01-02T15:04:05Z")
                }</span>
                <span class="cov0" title="0">fmt.Print(Logf(constants.LOG_LEVEL_WARN, LogFormat, timestamp, message))</span>
                // fmt.Printf("%s[WARN   ]%s [%s] :: %s\n", constants.COLOR_YELLOW, constants.COLOR_NONE, timestamp, message)
        }
}

func Warnf(timestamp, format string, args ...interface{}) <span class="cov0" title="0">{
        if LogLevel &gt;= constants.LOG_LEVEL_WARN_NUM </span><span class="cov0" title="0">{
                if timestamp == "" </span><span class="cov0" title="0">{
                        timestamp = time.Now().UTC().Format("2006-01-02T15:04:05Z")
                }</span>
                <span class="cov0" title="0">fmt.Print(Logf(constants.LOG_LEVEL_WARN, LogFormat, timestamp, format, args...))</span>
                // fmt.Printf("%s[WARN   ]%s [%s] :: %s\n", constants.COLOR_YELLOW, constants.COLOR_NONE, timestamp, fmt.Sprintf(format, args...))
        }
}

func Swarnf(timestamp, format string, args ...interface{}) string <span class="cov0" title="0">{
        if LogLevel &gt;= constants.LOG_LEVEL_WARN_NUM </span><span class="cov0" title="0">{
                if timestamp == "" </span><span class="cov0" title="0">{
                        timestamp = time.Now().UTC().Format("2006-01-02T15:04:05Z")
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("%s[WARN   ]%s [%s] :: %s\n", constants.COLOR_YELLOW, constants.COLOR_NONE, timestamp, fmt.Sprintf(format, args...))</span>
        }
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// main.go

package main

import (
        "context"
        "crypto/tls"
        "fmt"
        "math/rand"
        "net/http"
        "scaffold/server/config"
        "scaffold/server/constants"
        "scaffold/server/logger"
        "scaffold/server/manager"
        "scaffold/server/worker"
        "time"

        "github.com/gin-gonic/gin"
)

var router *gin.Engine

func run(ctx context.Context, channel chan struct{}) <span class="cov2" title="2">{
        // Set Gin to production mode
        gin.SetMode(gin.ReleaseMode)

        config.LoadConfig()
        logger.SetLevel(config.Config.LogLevel)
        logger.SetFormat(config.Config.LogFormat)

        http.DefaultTransport.(*http.Transport).TLSClientConfig = &amp;tls.Config{InsecureSkipVerify: config.Config.TLSSkipVerify}

        router = gin.New()
        router.Use(gin.LoggerWithFormatter(logger.ConsoleLogFormatter))
        router.Use(gin.Recovery())

        logger.Infof("", "Running with port: %d", config.Config.Port)

        router.LoadHTMLGlob("templates/*")
        initializeRoutes()

        rand.Seed(time.Now().UnixNano())

        if config.Config.Node.Type == constants.NODE_TYPE_MANAGER </span><span class="cov1" title="1">{
                go manager.Run()
        }</span> else<span class="cov1" title="1"> {
                go worker.Run()
        }</span>

        <span class="cov2" title="2">routerPort := fmt.Sprintf(":%d", config.Config.Port)
        if config.Config.TLSEnabled </span><span class="cov0" title="0">{
                logger.Infof("", "Running with TLS loaded from %s and %s", config.Config.TLSCrtPath, config.Config.TLSKeyPath)
                go router.RunTLS(routerPort, config.Config.TLSCrtPath, config.Config.TLSKeyPath)
        }</span> else<span class="cov2" title="2"> {
                go router.Run(routerPort)
        }</span>
        <span class="cov2" title="2">for </span><span class="cov10" title="112">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0"> // if cancel() execute
                        channel &lt;- struct{}{}
                        return</span>
                default:<span class="cov10" title="112"></span>
                        // foobar
                }

                <span class="cov10" title="112">time.Sleep(1 * time.Second)</span>
        }
}

//        @title                        Scaffold Swagger API
//        @version                2.0
//        @description        Scaffold workflow tool
//        @termsOfService        http://swagger.io/terms/

//        @contact.name        John Carter
//        @contact.url        https://github.com/jfcarter2358/scaffold/issues
//        @contact.email        jfcarter2358@gmail.com

//        @license.name        MIT
//        @license.url        https://opensource.org/license/mit/
func main() <span class="cov0" title="0">{
        channel := make(chan struct{})
        ctx, _ := context.WithCancel(context.Background())
        run(ctx, channel)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package manager

import (
        "encoding/json"
        "fmt"
        "io/ioutil"
        "log"
        "net/http"
        "scaffold/server/auth"
        "scaffold/server/cascade"
        "scaffold/server/config"
        "scaffold/server/constants"
        "scaffold/server/filestore"
        "scaffold/server/health"
        "scaffold/server/logger"
        "scaffold/server/mongodb"
        "scaffold/server/proxy"
        "scaffold/server/state"
        "scaffold/server/user"
        "scaffold/server/utils"
        "strings"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/gorilla/mux"
)

var InProgress = map[string]map[string]string{}
var ToCheck = map[string]map[string]string{}

func Run() <span class="cov1" title="1">{
        mongodb.InitCollections()
        filestore.InitBucket()

        // r := http.NewServeMux()
        r := mux.NewRouter()
        // mux.Handle("/ws", websocket.Handler(run))
        r.HandleFunc("/{host}/{port}/{cascade}/{run}/{version}",
                func(w http.ResponseWriter, req *http.Request) </span><span class="cov0" title="0">{
                        proxy.NewProxy().ServeHTTP(w, req)
                }</span>)

        // http.Handle("/api/someAPI", apiHandler)
        // go http.ListenAndServe(fmt.Sprintf(":%d", config.Config.WSPort), proxy.NewProxy())

        <span class="cov1" title="1">server := &amp;http.Server{
                Addr:    fmt.Sprintf(":%d", config.Config.WSPort),
                Handler: r,
        }

        go func() </span><span class="cov1" title="1">{
                log.Printf("Running reverse proxy at %s://0.0.0.0:%d\n", config.Config.Protocol, config.Config.WSPort)

                if config.Config.TLSEnabled </span><span class="cov0" title="0">{
                        if serverErr := server.ListenAndServeTLS(config.Config.TLSCrtPath, config.Config.TLSKeyPath); serverErr != nil </span><span class="cov0" title="0">{
                                logger.Fatalf("", "Error running websocket server: %s", serverErr)
                        }</span>
                } else<span class="cov1" title="1"> {
                        if serverErr := server.ListenAndServe(); serverErr != nil </span><span class="cov0" title="0">{
                                logger.Fatalf("", "Error running websocket server: %s", serverErr)
                        }</span>
                }
        }()

        <span class="cov1" title="1">health.IsHealthy = true

        user.VerifyAdmin()
        auth.Nodes = make([]auth.NodeObject, 0)
        auth.UnknownNodes = make(map[string]auth.DegradedNodeObject)
        auth.UnknownNodes = make(map[string]auth.DegradedNodeObject)

        health.IsReady = true

        InProgress = make(map[string]map[string]string)
        ToCheck = make(map[string]map[string]string)

        for </span><span class="cov8" title="121">{
                newNodes := []auth.NodeObject{}
                for _, n := range auth.Nodes </span><span class="cov7" title="100">{
                        queryURL := fmt.Sprintf("%s://%s:%d/health/healthy", n.Protocol, n.Host, n.Port)
                        logger.Debugf("", "Querying %s", queryURL)
                        resp, err := http.Get(queryURL)
                        if err != nil </span><span class="cov0" title="0">{
                                auth.UnknownNodes[n.Host] = auth.DegradedNodeObject{
                                        Node:  n,
                                        Count: 1,
                                }
                                continue</span>
                        }
                        <span class="cov7" title="100">logger.Debugf("", "Got response code %d", resp.StatusCode)
                        if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                                auth.UnhealthyNodes[n.Host] = auth.DegradedNodeObject{
                                        Node:  n,
                                        Count: 1,
                                }
                                continue</span>
                        }
                        <span class="cov7" title="100">newNodes = append(newNodes, n)</span>
                }
                // Check unhealthy nodes for status change
                <span class="cov8" title="121">toDelete := []string{}
                for _, n := range auth.UnhealthyNodes </span><span class="cov0" title="0">{
                        queryURL := fmt.Sprintf("%s://%s:%d/health/healthy", n.Node.Protocol, n.Node.Host, n.Node.Port)
                        logger.Debugf("", "Querying %s", queryURL)
                        resp, err := http.Get(queryURL)
                        logger.Debugf("", "Got response code %d", resp.StatusCode)
                        if err != nil </span><span class="cov0" title="0">{
                                auth.UnknownNodes[n.Node.Host] = auth.DegradedNodeObject{
                                        Node:  n.Node,
                                        Count: 1,
                                }
                                toDelete = append(toDelete, n.Node.Host)
                                continue</span>
                        }
                        <span class="cov0" title="0">if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">newNodes = append(newNodes, n.Node)
                        toDelete = append(toDelete, n.Node.Host)</span>
                }

                <span class="cov8" title="121">for _, key := range toDelete </span><span class="cov0" title="0">{
                        delete(auth.UnhealthyNodes, key)
                }</span>

                // Check unknown nodes for status change
                <span class="cov8" title="121">toDelete = []string{}
                for _, n := range auth.UnknownNodes </span><span class="cov0" title="0">{
                        queryURL := fmt.Sprintf("%s://%s:%d/health/healthy", n.Node.Protocol, n.Node.Host, n.Node.Port)
                        logger.Debugf("", "Querying %s", queryURL)
                        resp, err := http.Get(queryURL)
                        logger.Debugf("", "Got response code %d", resp.StatusCode)
                        if err != nil </span><span class="cov0" title="0">{
                                val := auth.UnknownNodes[n.Node.Host]
                                val.Count += 1
                                if val.Count &gt;= config.Config.HeartbeatBackoff </span><span class="cov0" title="0">{
                                        toDelete = append(toDelete, n.Node.Host)
                                }</span>
                                <span class="cov0" title="0">auth.UnknownNodes[n.Node.Host] = val
                                continue</span>
                        }
                        <span class="cov0" title="0">if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                                auth.UnhealthyNodes[n.Node.Host] = auth.DegradedNodeObject{
                                        Node:  n.Node,
                                        Count: 1,
                                }
                                toDelete = append(toDelete, n.Node.Host)
                                continue</span>
                        }
                        <span class="cov0" title="0">newNodes = append(newNodes, n.Node)
                        toDelete = append(toDelete, n.Node.Host)</span>
                }

                <span class="cov8" title="121">for _, key := range toDelete </span><span class="cov0" title="0">{
                        delete(auth.UnknownNodes, key)
                }</span>

                <span class="cov8" title="121">auth.Nodes = newNodes

                cascades, err := cascade.GetAllCascades()
                if err == nil </span><span class="cov5" title="19">{
                        for _, c := range cascades </span><span class="cov7" title="64">{
                                taskMap := map[string]string{}
                                if _, ok := ToCheck[c.Name]; ok </span><span class="cov4" title="12">{
                                        taskMap = ToCheck[c.Name]
                                }</span>
                                <span class="cov7" title="64">for _, t := range c.Tasks </span><span class="cov10" title="384">{
                                        for key := range taskMap </span><span class="cov8" title="198">{
                                                if strings.HasPrefix(key, t.Name) </span><span class="cov6" title="33">{
                                                        parts := strings.Split(key, ".")
                                                        hostPort := taskMap[key]
                                                        httpClient := http.Client{}
                                                        requestURL := fmt.Sprintf("%s/api/v1/state/%s/%s/%s", hostPort, c.Name, t.Name, parts[1])
                                                        req, _ := http.NewRequest("GET", requestURL, nil)
                                                        req.Header.Set("Authorization", fmt.Sprintf("X-Scaffold-API %s", config.Config.Node.PrimaryKey))
                                                        req.Header.Set("Content-Type", "application/json")
                                                        resp, err := httpClient.Do(req)

                                                        if err != nil </span><span class="cov0" title="0">{
                                                                logger.Errorf("", "Error getting run state %s.%s: %s", c.Name, t.Name, err.Error())
                                                                continue</span>
                                                        }
                                                        <span class="cov6" title="33">if resp.StatusCode == http.StatusOK </span><span class="cov0" title="0">{
                                                                //Read the response body
                                                                body, err := ioutil.ReadAll(resp.Body)
                                                                if err != nil </span><span class="cov0" title="0">{
                                                                        logger.Errorf("", "Error reading body: %s", err.Error())
                                                                        continue</span>
                                                                }
                                                                <span class="cov0" title="0">var s state.State
                                                                var temp map[string]interface{}
                                                                json.Unmarshal(body, &amp;temp)

                                                                tempBytes, _ := json.Marshal(temp)
                                                                json.Unmarshal(tempBytes, &amp;s)

                                                                state.UpdateStateByNames(c.Name, t.Name, &amp;s)

                                                                logger.Tracef("", "Got state %s", s.Status)

                                                                if s.Status == constants.STATE_STATUS_SUCCESS </span><span class="cov0" title="0">{
                                                                        logger.Debugf("", "Task %s has completed with success, removing from InProgress", key)
                                                                        triggerDepends(c, t.Name, constants.STATUS_TRIGGER_SUCCESS)
                                                                        triggerDepends(c, t.Name, constants.STATUS_TRIGGER_ALWAYS)
                                                                        delete(InProgress[c.Name], key)
                                                                        delete(ToCheck[c.Name], key)
                                                                }</span> else<span class="cov0" title="0"> if s.Status == constants.STATE_STATUS_ERROR </span><span class="cov0" title="0">{
                                                                        logger.Debugf("", "Task %s has completed with error, removing from InProgress", key)
                                                                        triggerDepends(c, t.Name, constants.STATUS_TRIGGER_ERROR)
                                                                        triggerDepends(c, t.Name, constants.STATUS_TRIGGER_ALWAYS)
                                                                        delete(ToCheck[c.Name], key)
                                                                }</span>

                                                                <span class="cov0" title="0">resp.Body.Close()</span>
                                                        }
                                                }
                                        }
                                        <span class="cov10" title="384">checkStateName := fmt.Sprintf("SCAFFOLD_CHECK-%s", t.Name)
                                        for key := range taskMap </span><span class="cov8" title="198">{
                                                if strings.HasPrefix(key, checkStateName) </span><span class="cov0" title="0">{
                                                        parts := strings.Split(key, ".")
                                                        hostPort := taskMap[key]
                                                        httpClient := http.Client{}
                                                        requestURL := fmt.Sprintf("%s/api/v1/state/%s/%s/%s", hostPort, c.Name, checkStateName, parts[1])
                                                        req, _ := http.NewRequest("GET", requestURL, nil)
                                                        req.Header.Set("Authorization", fmt.Sprintf("X-Scaffold-API %s", config.Config.Node.PrimaryKey))
                                                        req.Header.Set("Content-Type", "application/json")
                                                        resp, err := httpClient.Do(req)

                                                        if err != nil </span><span class="cov0" title="0">{
                                                                logger.Errorf("", "Error getting run state %s.%s: %s", c.Name, checkStateName, err.Error())
                                                                continue</span>
                                                        }
                                                        <span class="cov0" title="0">if resp.StatusCode == http.StatusOK </span><span class="cov0" title="0">{
                                                                //Read the response body
                                                                body, err := ioutil.ReadAll(resp.Body)
                                                                if err != nil </span><span class="cov0" title="0">{
                                                                        logger.Errorf("", "Error reading body: %s", err.Error())
                                                                        continue</span>
                                                                }
                                                                <span class="cov0" title="0">var s state.State
                                                                var temp map[string]interface{}
                                                                json.Unmarshal(body, &amp;temp)

                                                                logger.Debugf("", "Raw worker state: %v", temp)

                                                                tempBytes, _ := json.Marshal(temp)
                                                                json.Unmarshal(tempBytes, &amp;s)

                                                                logger.Debugf("", "Got state from worker: %v", &amp;s)

                                                                state.UpdateStateByNames(c.Name, checkStateName, &amp;s)

                                                                if s.Status == constants.STATE_STATUS_SUCCESS </span><span class="cov0" title="0">{
                                                                        logger.Debugf("", "Removing state %s from InProgress", checkStateName)
                                                                        delete(InProgress[c.Name], key)
                                                                        delete(ToCheck[c.Name], key)
                                                                }</span>
                                                                <span class="cov0" title="0">if s.Status == constants.STATE_STATUS_ERROR </span><span class="cov0" title="0">{
                                                                        ss, err := state.GetStateByNames(c.Name, t.Name)
                                                                        if err != nil </span><span class="cov0" title="0">{
                                                                                logger.Errorf("", "Issue getting state %s %s: %s", c.Name, t.Name, err.Error())
                                                                                continue</span>
                                                                        }
                                                                        <span class="cov0" title="0">ss.Status = constants.STATE_STATUS_ERROR
                                                                        state.UpdateStateByNames(c.Name, t.Name, ss)
                                                                        triggerDepends(c, t.Name, constants.STATUS_TRIGGER_ERROR)
                                                                        triggerDepends(c, t.Name, constants.STATUS_TRIGGER_ALWAYS)
                                                                        delete(InProgress[c.Name], key)
                                                                        delete(ToCheck[c.Name], key)</span>
                                                                }

                                                                <span class="cov0" title="0">resp.Body.Close()</span>
                                                        }
                                                }
                                        }
                                        <span class="cov10" title="384">if t.Check.Interval &gt; 0 </span><span class="cov8" title="128">{
                                                s, err := state.GetStateByNames(c.Name, t.Name)
                                                if err != nil </span><span class="cov5" title="18">{
                                                        logger.Errorf("", "Issue getting state %s %s: %s", c.Name, t.Name, err.Error())
                                                        continue</span>
                                                }

                                                <span class="cov8" title="110">if s.Status != constants.STATE_STATUS_SUCCESS </span><span class="cov8" title="110">{
                                                        continue</span>
                                                }

                                                <span class="cov0" title="0">if s.Finished == "" </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }
                                                <span class="cov0" title="0">currentTime := time.Now().UTC()
                                                logger.Debugf("", "State finished: %s", s.Finished)
                                                lastRun, _ := time.Parse("2006-01-02T15:04:05Z MST", fmt.Sprintf("%s UTC", s.Finished))

                                                cs, err := state.GetStateByNames(c.Name, checkStateName)
                                                if err == nil </span><span class="cov0" title="0">{
                                                        logger.Debugf("", "Found state for %s", checkStateName)
                                                        if cs.Finished != "" </span><span class="cov0" title="0">{
                                                                lastRun, _ = time.Parse("2006-01-02T15:04:05Z MST", fmt.Sprintf("%s UTC", cs.Finished))
                                                                logger.Debugf("", "Check state finished: %s", cs.Finished)
                                                                logger.Debugf("", "Check run is of status %s", cs.Status)
                                                        }</span>
                                                        <span class="cov0" title="0">if cs.Status == constants.STATE_STATUS_RUNNING || cs.Status == constants.STATE_STATUS_WAITING </span><span class="cov0" title="0">{
                                                                logger.Debugf("", "Check run is of status %s", cs.Status)
                                                                continue</span>
                                                        }
                                                } else<span class="cov0" title="0"> {
                                                        logger.Warnf("", "No state found for %s", checkStateName)
                                                }</span>

                                                <span class="cov0" title="0">diff := int(currentTime.Sub(lastRun).Seconds())

                                                if diff &lt; t.Check.Interval </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }

                                                <span class="cov0" title="0">logger.Debugf("", "Triggering check run for %s %s", c.Name, t.Name)
                                                httpClient := http.Client{}
                                                requestURL := fmt.Sprintf("%s://localhost:%d/api/v1/run/%s/%s/check", config.Config.Protocol, config.Config.Port, c.Name, t.Name)
                                                req, _ := http.NewRequest("POST", requestURL, nil)
                                                req.Header.Set("Authorization", fmt.Sprintf("X-Scaffold-API %s", config.Config.Node.PrimaryKey))
                                                req.Header.Set("Content-Type", "application/json")
                                                resp, err := httpClient.Do(req)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        logger.Error("", err.Error())
                                                        continue</span>
                                                }
                                                <span class="cov0" title="0">if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                                                        logger.Errorf("", "Received trigger status code %d", resp.StatusCode)
                                                }</span>
                                        }
                                }
                        }
                }
                <span class="cov8" title="121">time.Sleep(time.Duration(config.Config.HeartbeatInterval) * time.Millisecond)</span>
        }
}

func triggerDepends(c *cascade.Cascade, tn, status string) <span class="cov0" title="0">{
        toTrigger := []string{}
        states, _ := state.GetStatesByCascade(c.Name)
        switch status </span>{
        case constants.STATUS_TRIGGER_SUCCESS:<span class="cov0" title="0">
                for _, s := range states </span><span class="cov0" title="0">{
                        if s.Status == constants.STATE_STATUS_SUCCESS </span><span class="cov0" title="0">{
                                toTrigger = append(toTrigger, s.Task)
                        }</span>
                }
        case constants.STATUS_TRIGGER_ERROR:<span class="cov0" title="0">
                for _, s := range states </span><span class="cov0" title="0">{
                        if s.Status == constants.STATE_STATUS_ERROR </span><span class="cov0" title="0">{
                                toTrigger = append(toTrigger, s.Task)
                        }</span>
                }
        case constants.STATUS_TRIGGER_ALWAYS:<span class="cov0" title="0">
                for _, s := range states </span><span class="cov0" title="0">{
                        if s.Status == constants.STATE_STATUS_ERROR || s.Status == constants.STATE_STATUS_SUCCESS </span><span class="cov0" title="0">{
                                toTrigger = append(toTrigger, s.Task)
                        }</span>
                }
        }
        <span class="cov0" title="0">for _, t := range c.Tasks </span><span class="cov0" title="0">{
                dependsOn := make([]string, 0)
                switch status </span>{
                case constants.STATUS_TRIGGER_SUCCESS:<span class="cov0" title="0">
                        if t.DependsOn.Success == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">dependsOn = append(dependsOn, t.DependsOn.Success...)</span>
                case constants.STATUS_TRIGGER_ERROR:<span class="cov0" title="0">
                        if t.DependsOn.Error == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">dependsOn = append(dependsOn, t.DependsOn.Error...)</span>
                case constants.STATUS_TRIGGER_ALWAYS:<span class="cov0" title="0">
                        if t.DependsOn.Always == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">dependsOn = append(dependsOn, t.DependsOn.Always...)</span>
                }
                <span class="cov0" title="0">if utils.Contains(dependsOn, tn) </span><span class="cov0" title="0">{
                        shouldTrigger := true
                        for _, n := range dependsOn </span><span class="cov0" title="0">{
                                if !utils.Contains(toTrigger, n) </span><span class="cov0" title="0">{
                                        shouldTrigger = false
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if !shouldTrigger || !t.AutoExecute </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">httpClient := http.Client{}
                        requestURL := fmt.Sprintf("%s://localhost:%d/api/v1/run/%s/%s", config.Config.Protocol, config.Config.Port, c.Name, t.Name)
                        req, _ := http.NewRequest("POST", requestURL, nil)
                        req.Header.Set("Authorization", fmt.Sprintf("X-Scaffold-API %s", config.Config.Node.PrimaryKey))
                        req.Header.Set("Content-Type", "application/json")
                        resp, err := httpClient.Do(req)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Errorf("", "Depends run trigger error: %s", err.Error())
                                continue</span>
                        }
                        <span class="cov0" title="0">if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                                logger.Errorf("", "Received trigger status code %d", resp.StatusCode)
                                panic(fmt.Sprintf("Received trigger status code %d", resp.StatusCode))</span>
                        }
                }
        }
}

func InputChangeStateChange(name string, changed []string) error <span class="cov2" title="2">{
        c, err := cascade.GetCascadeByName(name)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov2" title="2">for _, i := range changed </span><span class="cov1" title="1">{
                for _, t := range c.Tasks </span><span class="cov3" title="6">{
                        ss, err := state.GetStateByNames(c.Name, t.Name)
                        if err == nil </span><span class="cov3" title="6">{
                                previousName := fmt.Sprintf("SCAFFOLD_PREVIOUS-%s", t.Name)
                                ss.Task = previousName
                                state.UpdateStateByNames(c.Name, previousName, ss)
                        }</span>
                        <span class="cov3" title="6">s := &amp;state.State{
                                Task:     t.Name,
                                Cascade:  c.Name,
                                Status:   constants.STATE_STATUS_NOT_STARTED,
                                Started:  "",
                                Finished: "",
                                Output:   "",
                                Number:   t.RunNumber,
                                Display:  make([]map[string]interface{}, 0),
                        }
                        if err := state.UpdateStateByNames(c.Name, s.Task, s); err != nil </span><span class="cov0" title="0">{
                                logger.Errorf("", "Cannot update state %s %s: %s", c.Name, t.Name, err.Error())
                                continue</span>
                        }
                        <span class="cov3" title="6">if utils.Contains(utils.Keys(t.Inputs), i) </span><span class="cov1" title="1">{
                                SetDependsState(c, t.Name)
                        }</span>
                }
        }
        <span class="cov2" title="2">return nil</span>
}

func SetDependsState(c *cascade.Cascade, tn string) <span class="cov5" title="20">{
        for _, t := range c.Tasks </span><span class="cov8" title="120">{
                dependsOn := make([]string, 0)
                if t.DependsOn.Success != nil </span><span class="cov6" title="40">{
                        dependsOn = append(dependsOn, t.DependsOn.Success...)
                }</span>
                <span class="cov8" title="120">if t.DependsOn.Error != nil </span><span class="cov5" title="20">{
                        dependsOn = append(dependsOn, t.DependsOn.Error...)
                }</span>
                <span class="cov8" title="120">if t.DependsOn.Always != nil </span><span class="cov5" title="20">{
                        dependsOn = append(dependsOn, t.DependsOn.Always...)
                }</span>
                <span class="cov8" title="120">if utils.Contains(dependsOn, tn) </span><span class="cov5" title="16">{
                        if !utils.Contains(dependsOn, tn) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov5" title="16">ss, err := state.GetStateByNames(c.Name, t.Name)
                        if err == nil </span><span class="cov5" title="16">{
                                previousName := fmt.Sprintf("SCAFFOLD_PREVIOUS-%s", t.Name)
                                ss.Task = previousName
                                state.UpdateStateByNames(c.Name, previousName, ss)
                        }</span>
                        <span class="cov5" title="16">s := &amp;state.State{
                                Task:     t.Name,
                                Cascade:  c.Name,
                                Status:   constants.STATE_STATUS_NOT_STARTED,
                                Started:  "",
                                Finished: "",
                                Output:   "",
                                Number:   t.RunNumber,
                                Display:  make([]map[string]interface{}, 0),
                        }
                        if err := state.UpdateStateByNames(c.Name, s.Task, s); err != nil </span><span class="cov0" title="0">{
                                logger.Errorf("", "Cannot update state %s %s: %s", c.Name, s.Task, err.Error())
                                continue</span>
                        }
                        <span class="cov5" title="16">SetDependsState(c, s.Task)</span>
                }
        }
}

//
//        @Summary                Get status of all nodes
//        @Description        Get status from all nodes
//        @tags                        manager
//        @tags                        health
//        @accept                        json
//        @produce                json
//        @Success                200        {object}        object
//        @Router                        /health/status [get]
func GetStatus(ctx *gin.Context) <span class="cov0" title="0">{
        nodes := make([]map[string]string, 0)
        managerStatus := "healthy"
        if !health.IsHealthy </span><span class="cov0" title="0">{
                managerStatus = "degraded"
        }</span>
        <span class="cov0" title="0">nodes = append(nodes, map[string]string{"name": config.Config.Host, "status": managerStatus, "version": constants.VERSION})
        for _, node := range auth.Nodes </span><span class="cov0" title="0">{
                nodes = append(nodes, map[string]string{"name": node.Host, "status": "healthy", "version": node.Version})
        }</span>
        <span class="cov0" title="0">for key, node := range auth.UnknownNodes </span><span class="cov0" title="0">{
                nodes = append(nodes, map[string]string{"name": key, "status": "unknown", "version": node.Node.Version})
        }</span>
        <span class="cov0" title="0">for key, node := range auth.UnhealthyNodes </span><span class="cov0" title="0">{
                nodes = append(nodes, map[string]string{"name": key, "status": "degraded", "version": node.Node.Version})
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{"nodes": nodes})</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package middleware

import (
        "net/http"
        "scaffold/server/cascade"
        "scaffold/server/config"
        "scaffold/server/user"
        "scaffold/server/utils"
        "strings"

        "github.com/gin-gonic/gin"
)

// This middleware ensures that a request will be aborted with an error
// if the user is not logged in
func EnsureLoggedIn() gin.HandlerFunc <span class="cov7" title="56">{
        return func(c *gin.Context) </span><span class="cov8" title="155">{
                var token string
                var err error

                baUsername, baPassword, hasAuth := c.Request.BasicAuth()
                if hasAuth </span><span class="cov3" title="5">{
                        _, err := user.GetUserByUsername(baUsername)
                        if err != nil </span><span class="cov0" title="0">{
                                c.AbortWithStatus(http.StatusUnauthorized)
                                return
                        }</span>
                        <span class="cov3" title="5">verified, err := user.VerifyUser(baUsername, baPassword)
                        if err != nil || !verified </span><span class="cov0" title="0">{
                                c.AbortWithStatus(http.StatusUnauthorized)
                                return
                        }</span>
                        <span class="cov3" title="5">return</span>
                }

                <span class="cov8" title="150">authString := c.Request.Header.Get("Authorization")
                if authString == "" </span><span class="cov0" title="0">{
                        token, err = c.Cookie("scaffold_token")
                        if err != nil </span><span class="cov0" title="0">{
                                c.Redirect(307, "/ui/login")
                                return
                        }</span>
                } else<span class="cov8" title="150"> {
                        token = strings.Split(authString, " ")[1]
                }</span>
                <span class="cov8" title="150">if token == config.Config.Node.PrimaryKey </span><span class="cov3" title="6">{
                        return
                }</span>

                <span class="cov8" title="144">usr, _ := user.GetUserByAPIToken(token)
                if usr != nil </span><span class="cov8" title="144">{
                        return
                }</span>

                <span class="cov0" title="0">usr, _ = user.GetUserByLoginToken(token)
                if usr == nil </span><span class="cov0" title="0">{
                        if authString == "" </span><span class="cov0" title="0">{
                                c.Redirect(307, "/ui/login")
                                return
                        }</span>
                        <span class="cov0" title="0">c.AbortWithStatus(http.StatusUnauthorized)</span>
                }
        }
}

func EnsureNotLoggedIn() gin.HandlerFunc <span class="cov4" title="8">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                var token string
                var err error

                authString := c.Request.Header.Get("Authorization")
                if authString == "" </span><span class="cov0" title="0">{
                        token, err = c.Cookie("scaffold_token")
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                } else<span class="cov0" title="0"> {
                        token = strings.Split(authString, " ")[1]
                }</span>

                <span class="cov0" title="0">if token == config.Config.Node.PrimaryKey </span><span class="cov0" title="0">{
                        c.AbortWithStatus(http.StatusUnauthorized)
                        return
                }</span>
                <span class="cov0" title="0">usr, _ := user.GetUserByAPIToken(token)
                if usr != nil </span><span class="cov0" title="0">{
                        c.AbortWithStatus(http.StatusUnauthorized)
                }</span>

                <span class="cov0" title="0">usr, _ = user.GetUserByLoginToken(token)
                if usr != nil </span><span class="cov0" title="0">{
                        c.AbortWithStatus(http.StatusUnauthorized)
                }</span>
        }
}

// This middleware ensures that a request will be aborted with an error
// if the user is not logged in
func EnsureCascadeGroup(paramName string) gin.HandlerFunc <span class="cov5" title="27">{
        return func(c *gin.Context) </span><span class="cov7" title="98">{
                var token string
                var err error
                isUI := false
                cascadeName := c.Param(paramName)
                cs, _ := cascade.GetCascadeByName(cascadeName)
                if err != nil </span><span class="cov0" title="0">{
                        c.AbortWithStatus(http.StatusUnauthorized)
                }</span>
                <span class="cov7" title="98">if cs == nil </span><span class="cov2" title="3">{
                        return
                }</span>

                <span class="cov7" title="95">authString := c.Request.Header.Get("Authorization")
                if authString == "" </span><span class="cov0" title="0">{
                        token, err = c.Cookie("scaffold_token")
                        if err != nil </span><span class="cov0" title="0">{
                                c.Redirect(http.StatusUnauthorized, "/ui/401")
                                return
                        }</span>
                        <span class="cov0" title="0">isUI = true</span>
                } else<span class="cov7" title="95"> {
                        token = strings.Split(authString, " ")[1]
                }</span>
                <span class="cov7" title="95">if token == config.Config.Node.PrimaryKey </span><span class="cov2" title="2">{
                        return
                }</span>

                <span class="cov7" title="93">usr, _ := user.GetUserByAPIToken(token)
                if usr != nil </span><span class="cov7" title="93">{
                        if utils.Contains(usr.Groups, "admin") </span><span class="cov5" title="21">{
                                return
                        }</span>
                        <span class="cov7" title="72">if cs.Groups == nil </span><span class="cov5" title="16">{
                                return
                        }</span>
                        <span class="cov7" title="56">for _, group := range cs.Groups </span><span class="cov7" title="56">{
                                if utils.Contains(usr.Groups, group) </span><span class="cov6" title="32">{
                                        return
                                }</span>
                        }
                        <span class="cov5" title="24">if isUI </span><span class="cov0" title="0">{
                                c.Redirect(http.StatusUnauthorized, "/ui/401")
                                return
                        }</span>
                        <span class="cov5" title="24">c.AbortWithStatus(http.StatusUnauthorized)</span>
                }

                <span class="cov5" title="24">usr, _ = user.GetUserByLoginToken(token)
                if usr != nil </span><span class="cov0" title="0">{
                        if utils.Contains(usr.Groups, "admin") </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">for _, group := range cs.Groups </span><span class="cov0" title="0">{
                                if utils.Contains(usr.Groups, group) </span><span class="cov0" title="0">{
                                        return
                                }</span>
                        }
                        <span class="cov0" title="0">if isUI </span><span class="cov0" title="0">{
                                c.Redirect(http.StatusUnauthorized, "/ui/401")
                                return
                        }</span>
                        <span class="cov0" title="0">c.AbortWithStatus(http.StatusUnauthorized)</span>
                }
                <span class="cov5" title="24">if isUI </span><span class="cov0" title="0">{
                        c.Redirect(http.StatusUnauthorized, "/ui/401")
                        return
                }</span>
                <span class="cov5" title="24">c.AbortWithStatus(http.StatusUnauthorized)</span>
        }
}

func EnsureSelf() gin.HandlerFunc <span class="cov2" title="2">{
        return func(c *gin.Context) </span><span class="cov3" title="5">{
                username := c.Param("username")

                var token string
                var err error

                baUsername, baPassword, hasAuth := c.Request.BasicAuth()
                if hasAuth </span><span class="cov3" title="5">{
                        if baUsername != username </span><span class="cov0" title="0">{
                                c.AbortWithStatus(http.StatusUnauthorized)
                        }</span>
                        <span class="cov3" title="5">_, err := user.GetUserByUsername(baUsername)
                        if err != nil </span><span class="cov0" title="0">{
                                c.AbortWithStatus(http.StatusUnauthorized)
                                return
                        }</span>
                        <span class="cov3" title="5">verified, err := user.VerifyUser(baUsername, baPassword)
                        if err != nil || !verified </span><span class="cov0" title="0">{
                                c.AbortWithStatus(http.StatusUnauthorized)
                                return
                        }</span>
                        <span class="cov3" title="5">return</span>
                }

                <span class="cov0" title="0">authString := c.Request.Header.Get("Authorization")
                if authString == "" </span><span class="cov0" title="0">{
                        token, err = c.Cookie("scaffold_token")
                        if err != nil </span><span class="cov0" title="0">{
                                c.Redirect(307, "/ui/login")
                                return
                        }</span>
                } else<span class="cov0" title="0"> {
                        token = strings.Split(authString, " ")[1]
                }</span>
                <span class="cov0" title="0">if token == config.Config.Node.PrimaryKey </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">usr, _ := user.GetUserByAPIToken(token)
                if usr != nil </span><span class="cov0" title="0">{
                        if usr.Username == username || StringSliceContains(usr.Groups, "admin") || StringSliceContains(usr.Roles, "admin") </span><span class="cov0" title="0">{
                                return
                        }</span>
                }

                <span class="cov0" title="0">usr, _ = user.GetUserByLoginToken(token)
                if usr == nil </span><span class="cov0" title="0">{
                        if authString == "" </span><span class="cov0" title="0">{
                                c.Redirect(307, "/ui/login")
                                return
                        }</span>
                        <span class="cov0" title="0">c.AbortWithStatus(http.StatusUnauthorized)</span>
                }
                <span class="cov0" title="0">if usr.Username == username || StringSliceContains(usr.Groups, "admin") || StringSliceContains(usr.Roles, "admin") </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">if authString == "" </span><span class="cov0" title="0">{
                        c.Redirect(307, "/ui/login")
                        return
                }</span>
                <span class="cov0" title="0">c.AbortWithStatus(http.StatusUnauthorized)</span>
        }
}

func EnsureGroupsAllowed(groups []string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                var usr *user.User
                authString := c.Request.Header.Get("Authorization")
                found := false
                if authString == "" </span><span class="cov0" title="0">{
                        token, err := c.Cookie("scaffold_token")
                        if err == nil </span><span class="cov0" title="0">{
                                usr, err = user.GetUserByLoginToken(token)
                                if err != nil </span><span class="cov0" title="0">{
                                        found = true
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        if !found </span><span class="cov0" title="0">{
                                token := strings.Split(authString, " ")[1]
                                if token == config.Config.Node.PrimaryKey </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov0" title="0">var err error
                                usr, err = user.GetUserByAPIToken(token)
                                if err != nil </span><span class="cov0" title="0">{
                                        c.AbortWithStatus(http.StatusUnauthorized)
                                }</span>
                        }
                }
                <span class="cov0" title="0">if usr != nil </span><span class="cov0" title="0">{
                        for _, group := range usr.Groups </span><span class="cov0" title="0">{
                                if StringSliceContains(groups, group) </span><span class="cov0" title="0">{
                                        return
                                }</span>
                        }
                }
                <span class="cov0" title="0">c.AbortWithStatus(http.StatusUnauthorized)</span>
        }
}

func EnsureRolesAllowed(roles []string) gin.HandlerFunc <span class="cov6" title="43">{
        return func(c *gin.Context) </span><span class="cov8" title="150">{
                var usr *user.User
                var err error

                authString := c.Request.Header.Get("Authorization")
                if authString == "" </span><span class="cov0" title="0">{
                        token, err := c.Cookie("scaffold_token")
                        if err != nil </span><span class="cov0" title="0">{
                                c.AbortWithStatus(http.StatusUnauthorized)
                                return
                        }</span>
                        <span class="cov0" title="0">usr, err = user.GetUserByLoginToken(token)
                        if err != nil </span><span class="cov0" title="0">{
                                c.AbortWithStatus(http.StatusUnauthorized)
                                return
                        }</span>
                } else<span class="cov8" title="150"> {
                        token := strings.Split(authString, " ")[1]
                        if token == config.Config.Node.PrimaryKey </span><span class="cov3" title="6">{
                                return
                        }</span>
                        <span class="cov8" title="144">usr, err = user.GetUserByAPIToken(token)
                        if err != nil </span><span class="cov0" title="0">{
                                c.AbortWithStatus(http.StatusUnauthorized)
                                return
                        }</span>
                }
                <span class="cov8" title="144">if usr != nil </span><span class="cov8" title="144">{
                        for _, role := range usr.Roles </span><span class="cov8" title="169">{
                                if StringSliceContains(roles, role) </span><span class="cov8" title="143">{
                                        return
                                }</span>
                        }
                }
                <span class="cov1" title="1">c.AbortWithStatus(http.StatusUnauthorized)</span>
        }
}

func EnsureBasicAuth() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span>{<span class="cov0" title="0">

        }</span>
}

func StringSliceContains(list []string, item string) bool <span class="cov8" title="169">{
        for _, v := range list </span><span class="cov10" title="384">{
                if v == item </span><span class="cov8" title="143">{
                        return true
                }</span>
        }
        <span class="cov5" title="26">return false</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// middleware.cors.go

package middleware

import (
        "github.com/gin-gonic/gin"
)

func CORSMiddleware() gin.HandlerFunc <span class="cov3" title="6">{
        return func(c *gin.Context) </span><span class="cov10" title="256">{
                c.Writer.Header().Set("Access-Control-Allow-Origin", "*")
                c.Writer.Header().Set("Access-Control-Allow-Credentials", "true")
                c.Writer.Header().Set("Access-Control-Allow-Headers", "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With, X-Scaffold-API")
                c.Writer.Header().Set("Access-Control-Allow-Methods", "POST, OPTIONS, GET, PUT, DELETE, UPGRADE, HEAD, CONNECT, PATCH, TRACE")

                if c.Request.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        c.AbortWithStatus(204)
                        return
                }</span>

                <span class="cov10" title="256">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package mongodb

import (
        "context"
        "log"
        "scaffold/server/config"
        "scaffold/server/constants"

        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

var collectionNames = []string{
        constants.MONGODB_CASCADE_COLLECTION_NAME,
        constants.MONGODB_DATASTORE_COLLECTION_NAME,
        constants.MONGODB_STATE_COLLECTION_NAME,
        constants.MONGODB_USER_COLLECTION_NAME,
        constants.MONGODB_TASK_COLLECTION_NAME,
        constants.MONGODB_INPUT_COLLECTION_NAME,
}
var Collections map[string]*mongo.Collection
var Ctx = context.TODO()

func InitCollections() <span class="cov3" title="2">{
        clientOptions := options.Client().ApplyURI(config.Config.DBConnectionString)
        client, err := mongo.Connect(Ctx, clientOptions)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov3" title="2">err = client.Ping(Ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov3" title="2">Collections = make(map[string]*mongo.Collection)

        for _, collection := range collectionNames </span><span class="cov10" title="12">{
                Collections[collection] = client.Database(config.Config.DB.Name).Collection(collection)
        }</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package page

import (
        "encoding/json"
        "fmt"
        "net/http"
        "scaffold/server/auth"
        "scaffold/server/cascade"
        "scaffold/server/config"
        "scaffold/server/constants"
        "scaffold/server/datastore"
        "scaffold/server/filestore"
        "scaffold/server/logger"
        "scaffold/server/user"
        "scaffold/server/utils"
        "time"

        "github.com/gin-gonic/gin"
)

func RedirectIndexPage(c *gin.Context) <span class="cov0" title="0">{
        c.Redirect(301, "/ui/cascades")
}</span>

func ShowLoginPage(c *gin.Context) <span class="cov0" title="0">{
        showPage(c, "login.html", gin.H{})
}</span>

func ShowForgotPasswordPage(c *gin.Context) <span class="cov0" title="0">{
        showPage(c, "forgot_password.html", gin.H{})
}</span>

func ShowEmailSuccessPage(c *gin.Context) <span class="cov0" title="0">{
        showPage(c, "email_success.html", gin.H{})
}</span>

func ShowEmailFailurePage(c *gin.Context) <span class="cov0" title="0">{
        showPage(c, "email_failure.html", gin.H{})
}</span>

func ShowResetPasswordPage(c *gin.Context) <span class="cov0" title="0">{
        resetToken := c.Param("reset_token")
        u, _ := user.GetUserByResetToken(resetToken)

        if u == nil </span><span class="cov0" title="0">{
                showPage(c, "reset_password.html", gin.H{"title": "Reset Password", "Email": "N/A", "InvalidToken": "Your password reset link is invalid or expired"})
        }</span> else<span class="cov0" title="0"> {
                t, err := time.Parse("2006-01-02 15:04:05", u.ResetTokenCreated)
                if err != nil </span><span class="cov0" title="0">{
                        showPage(c, "reset_password.html", gin.H{"title": "Reset Password", "Email": "N/A", "InvalidToken": "Your password reset link is invalid or expired"})
                }</span> else<span class="cov0" title="0"> {
                        currentTime := time.Now()
                        difference := currentTime.Sub(t).Hours()
                        if difference &gt; 24 </span><span class="cov0" title="0">{
                                showPage(c, "reset_password.html", gin.H{"title": "Reset Password", "Email": "N/A", "InvalidToken": "Your password reset link is invalid or expired"})
                        }</span> else<span class="cov0" title="0"> {
                                showPage(c, "reset_password.html", gin.H{"title": "Reset Password", "Email": u.Email})
                        }</span>
                }
        }
}

func ShowCascadesPage(c *gin.Context) <span class="cov0" title="0">{
        token, _ := c.Cookie("scaffold_token")
        u, _ := user.GetUserByLoginToken(token)

        if u == nil </span><span class="cov0" title="0">{
                c.Redirect(http.StatusTemporaryRedirect, "/ui/401")
                return
        }</span>

        <span class="cov0" title="0">cascadePointers, _ := cascade.GetAllCascades()
        cascades := make([]map[string]interface{}, len(cascadePointers))
        for idx, obj := range cascadePointers </span><span class="cov0" title="0">{
                objBytes, _ := json.Marshal(obj)
                var data map[string]interface{}
                json.Unmarshal(objBytes, &amp;data)
                isInGroup := false
                for _, ug := range u.Groups </span><span class="cov0" title="0">{
                        if ug == "admin" </span><span class="cov0" title="0">{
                                isInGroup = true
                                break</span>
                        }
                        <span class="cov0" title="0">for _, cg := range obj.Groups </span><span class="cov0" title="0">{
                                if ug == cg </span><span class="cov0" title="0">{
                                        isInGroup = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if isInGroup </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">data["in_group"] = isInGroup
                cascades[idx] = data</span>
        }

        <span class="cov0" title="0">showPage(c, "cascades.html", gin.H{"cascades": cascades})</span>
}

func ShowCascadePage(c *gin.Context) <span class="cov0" title="0">{
        token, _ := c.Cookie("scaffold_token")
        u, _ := user.GetUserByLoginToken(token)

        if u == nil </span><span class="cov0" title="0">{
                c.Redirect(http.StatusTemporaryRedirect, "/ui/401")
                return
        }</span>

        <span class="cov0" title="0">name := c.Param("name")
        obj, err := cascade.GetCascadeByName(name)
        if err != nil </span><span class="cov0" title="0">{
                c.Redirect(http.StatusTemporaryRedirect, "/ui/500")
                return
        }</span>

        <span class="cov0" title="0">isInGroup := false
        for _, ug := range u.Groups </span><span class="cov0" title="0">{
                if ug == "admin" </span><span class="cov0" title="0">{
                        isInGroup = true
                        break</span>
                }
                <span class="cov0" title="0">for _, cg := range obj.Groups </span><span class="cov0" title="0">{
                        if ug == cg </span><span class="cov0" title="0">{
                                fmt.Println("In group!")
                                isInGroup = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if isInGroup </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">if !isInGroup </span><span class="cov0" title="0">{
                c.Redirect(http.StatusTemporaryRedirect, "/ui/401")
                return
        }</span>

        <span class="cov0" title="0">showPage(c, "cascade.html", gin.H{"cascade": *obj})</span>
}

func ShowFilesPage(c *gin.Context) <span class="cov0" title="0">{
        token, _ := c.Cookie("scaffold_token")
        u, _ := user.GetUserByLoginToken(token)

        if u == nil </span><span class="cov0" title="0">{
                c.Redirect(http.StatusTemporaryRedirect, "/ui/401")
                return
        }</span>

        <span class="cov0" title="0">objects := []filestore.ObjectMetadata{}
        fileMetadata, err := filestore.ListObjects()
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Unable to get filestore objects: %s", err.Error())
                utils.DynamicAPIResponse(c, "/ui/500", http.StatusInternalServerError, gin.H{})
        }</span>

        <span class="cov0" title="0">cascadeList := []string{}
        inGroups := map[string]bool{}

        datastores, _ := datastore.GetAllDataStores()
        cascades, _ := cascade.GetAllCascades()
        for idx, d := range datastores </span><span class="cov0" title="0">{
                cascadeList = append(cascadeList, d.Name)

                for _, f := range d.Files </span><span class="cov0" title="0">{
                        path := fmt.Sprintf("%s/%s", d.Name, f)
                        fm := filestore.ObjectMetadata{
                                Name:     f,
                                Cascade:  d.Name,
                                Modified: fileMetadata[path].Modified,
                        }
                        objects = append(objects, fm)
                }</span>
                <span class="cov0" title="0">isInGroup := false
                for _, ug := range u.Groups </span><span class="cov0" title="0">{
                        if ug == "admin" </span><span class="cov0" title="0">{
                                isInGroup = true
                                break</span>
                        }
                        <span class="cov0" title="0">for _, cg := range cascades[idx].Groups </span><span class="cov0" title="0">{
                                if ug == cg </span><span class="cov0" title="0">{
                                        isInGroup = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if isInGroup </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">inGroups[d.Name] = isInGroup</span>
        }

        <span class="cov0" title="0">showPage(c, "files.html", gin.H{"objects": objects, "cascades": cascadeList, "in_groups": inGroups})</span>
}

func ShowUsersPage(c *gin.Context) <span class="cov0" title="0">{
        token, _ := c.Cookie("scaffold_token")
        u, _ := user.GetUserByLoginToken(token)

        if u == nil </span><span class="cov0" title="0">{
                c.Redirect(http.StatusTemporaryRedirect, "/ui/401")
                return
        }</span>

        <span class="cov0" title="0">isAdmin := false
        if utils.Contains(u.Groups, "admin") || utils.Contains(u.Roles, "admin") </span><span class="cov0" title="0">{
                isAdmin = true
        }</span>

        <span class="cov0" title="0">groups, _ := auth.GetAllGroups()
        roles := auth.GetAllRoles()

        var users []user.User
        if isAdmin </span><span class="cov0" title="0">{
                userPointers, _ := user.GetAllUsers()
                users = make([]user.User, len(userPointers))
                for idx, obj := range userPointers </span><span class="cov0" title="0">{
                        users[idx] = *obj
                }</span>
        } else<span class="cov0" title="0"> {
                users = []user.User{*u}
        }</span>

        <span class="cov0" title="0">showPage(c, "users.html", gin.H{"users": users, "is_admin": isAdmin, "admin_username": config.Config.Admin.Username, "groups": groups, "roles": roles})</span>
}

func ShowUserPage(c *gin.Context) <span class="cov0" title="0">{
        username := c.Param("username")
        u, _ := user.GetUserByUsername(username)
        if u == nil </span><span class="cov0" title="0">{
                c.HTML(http.StatusNotFound, "/ui/404", gin.H{})
        }</span>

        <span class="cov0" title="0">groupObj := make([]map[string]string, len(u.Groups))
        for idx, val := range u.Groups </span><span class="cov0" title="0">{
                groupObj[idx] = map[string]string{
                        "value": val,
                }
        }</span>
        <span class="cov0" title="0">groupJSON, _ := json.Marshal(groupObj)

        roleObj := make([]map[string]string, len(u.Roles))
        for idx, val := range u.Roles </span><span class="cov0" title="0">{
                roleObj[idx] = map[string]string{
                        "value": val,
                }
        }</span>
        <span class="cov0" title="0">roleJSON, _ := json.Marshal(roleObj)

        logger.Debugf("", "group json: %s", string(groupJSON))
        logger.Debugf("", "role json: %s", string(roleJSON))

        showPage(c, "user.html", gin.H{"user": &amp;u, "role_tag_json": string(roleJSON), "group_tag_json": string(groupJSON)})</span>
}

func showPage(c *gin.Context, page string, header gin.H) <span class="cov0" title="0">{
        token, _ := c.Cookie("scaffold_token")
        u, _ := user.GetUserByLoginToken(token)

        familyName := ""
        givenName := ""
        if u != nil </span><span class="cov0" title="0">{
                familyName = u.FamilyName
                givenName = u.GivenName
        }</span>

        <span class="cov0" title="0">header["family_name"] = familyName
        header["given_name"] = givenName
        header["version"] = constants.VERSION

        render(c, header, page)</span>
}

func render(c *gin.Context, data gin.H, templateName string) <span class="cov0" title="0">{
        switch c.Request.Header.Get("Accept") </span>{
        case "application/json":<span class="cov0" title="0">
                c.JSON(http.StatusOK, data["payload"])</span>
        case "application/xml":<span class="cov0" title="0">
                c.XML(http.StatusOK, data["payload"])</span>
        default:<span class="cov0" title="0">
                c.HTML(http.StatusOK, templateName, data)</span>
        }
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package proxy

import (
        "fmt"
        "io"
        "log"
        "net"
        "net/http"
        "net/url"
        "scaffold/server/cascade"
        "scaffold/server/logger"
        "scaffold/server/user"
        "scaffold/server/utils"
        "strings"

        "github.com/gorilla/mux"
        "github.com/gorilla/websocket"
)

var (
        // DefaultUpgrader specifies the parameters for upgrading an HTTP
        // connection to a WebSocket connection.
        DefaultUpgrader = &amp;websocket.Upgrader{
                ReadBufferSize:  1024,
                WriteBufferSize: 1024,
        }

        // DefaultDialer is a dialer with all fields set to the default zero values.
        DefaultDialer = websocket.DefaultDialer
)

// WebsocketProxy is an HTTP Handler that takes an incoming WebSocket
// connection and proxies it to another server.
type WebsocketProxy struct {
        // Director, if non-nil, is a function that may copy additional request
        // headers from the incoming WebSocket connection into the output headers
        // which will be forwarded to another server.
        Director func(incoming *http.Request, out http.Header)

        // Backend returns the backend URL which the proxy uses to reverse proxy
        // the incoming WebSocket connection. Request is the initial incoming and
        // unmodified request.
        Backend func(*http.Request) *url.URL

        // Upgrader specifies the parameters for upgrading a incoming HTTP
        // connection to a WebSocket connection. If nil, DefaultUpgrader is used.
        Upgrader *websocket.Upgrader

        //  Dialer contains options for connecting to the backend WebSocket server.
        //  If nil, DefaultDialer is used.
        Dialer *websocket.Dialer
}

// ProxyHandler returns a new http.Handler interface that reverse proxies the
// request to the given target.
func ProxyHandler(target *url.URL) http.Handler <span class="cov0" title="0">{ return NewProxy() }</span>

// NewProxy returns a new Websocket reverse proxy that rewrites the
// URL's to the scheme, host and base path provider in target.
func NewProxy() *WebsocketProxy <span class="cov0" title="0">{
        backend := func(r *http.Request) *url.URL </span><span class="cov0" title="0">{
                vars := mux.Vars(r)
                host := vars["host"]
                port := vars["port"]
                cascadeName := vars["cascade"]
                run := vars["run"]
                version := vars["version"]

                c, err := cascade.GetCascadeByName(cascadeName)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalln(err)
                }</span>

                <span class="cov0" title="0">authString := r.Header.Get("Authorization")
                if authString == "" </span><span class="cov0" title="0">{
                        log.Fatalln("No auth header present")
                }</span>
                <span class="cov0" title="0">token := strings.Split(authString, " ")[1]

                usr, _ := user.GetUserByAPIToken(token)

                if usr == nil </span><span class="cov0" title="0">{
                        log.Fatalln("No user present that matches auth information")
                }</span>
                <span class="cov0" title="0">isValid := false
                for _, group := range c.Groups </span><span class="cov0" title="0">{
                        if utils.Contains(usr.Groups, group) </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        log.Fatalln("User is not permitted to access this container")
                }</span>

                <span class="cov0" title="0">logger.Tracef("Trying to exec with information %s, %s, %s, %s, %s", host, port, cascadeName, run, version)

                url, err := url.Parse(fmt.Sprintf("ws://%s:%s/ws/%s/%s/%s", host, port, cascadeName, run, version))
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalln(err)
                }</span>

                // Shallow copy
                <span class="cov0" title="0">u := *url
                u.Fragment = r.URL.Fragment
                // u.Path = r.URL.Path
                // u.RawQuery = r.URL.RawQuery
                return &amp;u</span>
        }
        <span class="cov0" title="0">return &amp;WebsocketProxy{Backend: backend}</span>
}

// ServeHTTP implements the http.Handler that proxies WebSocket connections.
func (w *WebsocketProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        if w.Backend == nil </span><span class="cov0" title="0">{
                log.Println("websocketproxy: backend function is not defined")
                http.Error(rw, "internal server error (code: 1)", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">backendURL := w.Backend(req)
        if backendURL == nil </span><span class="cov0" title="0">{
                log.Println("websocketproxy: backend URL is nil")
                http.Error(rw, "internal server error (code: 2)", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">dialer := w.Dialer
        if w.Dialer == nil </span><span class="cov0" title="0">{
                dialer = DefaultDialer
        }</span>

        // Pass headers from the incoming request to the dialer to forward them to
        // the final destinations.
        <span class="cov0" title="0">requestHeader := http.Header{}
        if origin := req.Header.Get("Origin"); origin != "" </span><span class="cov0" title="0">{
                requestHeader.Add("Origin", origin)
        }</span>
        <span class="cov0" title="0">for _, prot := range req.Header[http.CanonicalHeaderKey("Sec-WebSocket-Protocol")] </span><span class="cov0" title="0">{
                requestHeader.Add("Sec-WebSocket-Protocol", prot)
        }</span>
        <span class="cov0" title="0">for _, cookie := range req.Header[http.CanonicalHeaderKey("Cookie")] </span><span class="cov0" title="0">{
                requestHeader.Add("Cookie", cookie)
        }</span>
        <span class="cov0" title="0">if req.Host != "" </span><span class="cov0" title="0">{
                requestHeader.Set("Host", req.Host)
        }</span>

        // Pass X-Forwarded-For headers too, code below is a part of
        // httputil.ReverseProxy. See http://en.wikipedia.org/wiki/X-Forwarded-For
        // for more information
        // TODO: use RFC7239 http://tools.ietf.org/html/rfc7239
        <span class="cov0" title="0">if clientIP, _, err := net.SplitHostPort(req.RemoteAddr); err == nil </span><span class="cov0" title="0">{
                // If we aren't the first proxy retain prior
                // X-Forwarded-For information as a comma+space
                // separated list and fold multiple headers into one.
                if prior, ok := req.Header["X-Forwarded-For"]; ok </span><span class="cov0" title="0">{
                        clientIP = strings.Join(prior, ", ") + ", " + clientIP
                }</span>
                <span class="cov0" title="0">requestHeader.Set("X-Forwarded-For", clientIP)</span>
        }

        // Set the originating protocol of the incoming HTTP request. The SSL might
        // be terminated on our site and because we doing proxy adding this would
        // be helpful for applications on the backend.
        <span class="cov0" title="0">requestHeader.Set("X-Forwarded-Proto", "http")
        if req.TLS != nil </span><span class="cov0" title="0">{
                requestHeader.Set("X-Forwarded-Proto", "https")
        }</span>

        // Enable the director to copy any additional headers it desires for
        // forwarding to the remote server.
        <span class="cov0" title="0">if w.Director != nil </span><span class="cov0" title="0">{
                w.Director(req, requestHeader)
        }</span>

        // Connect to the backend URL, also pass the headers we get from the requst
        // together with the Forwarded headers we prepared above.
        // TODO: support multiplexing on the same backend connection instead of
        // opening a new TCP connection time for each request. This should be
        // optional:
        // http://tools.ietf.org/html/draft-ietf-hybi-websocket-multiplexing-01
        <span class="cov0" title="0">connBackend, resp, err := dialer.Dial(backendURL.String(), requestHeader)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("websocketproxy: couldn't dial to remote backend url %s", err)
                if resp != nil </span><span class="cov0" title="0">{
                        // If the WebSocket handshake fails, ErrBadHandshake is returned
                        // along with a non-nil *http.Response so that callers can handle
                        // redirects, authentication, etcetera.
                        if err := copyResponse(rw, resp); err != nil </span><span class="cov0" title="0">{
                                log.Printf("websocketproxy: couldn't write response after failed remote backend handshake: %s", err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        http.Error(rw, http.StatusText(http.StatusServiceUnavailable), http.StatusServiceUnavailable)
                }</span>
                <span class="cov0" title="0">return</span>
        }
        <span class="cov0" title="0">defer connBackend.Close()

        upgrader := w.Upgrader
        if w.Upgrader == nil </span><span class="cov0" title="0">{
                upgrader = DefaultUpgrader
        }</span>

        // Only pass those headers to the upgrader.
        <span class="cov0" title="0">upgradeHeader := http.Header{}
        if hdr := resp.Header.Get("Sec-Websocket-Protocol"); hdr != "" </span><span class="cov0" title="0">{
                upgradeHeader.Set("Sec-Websocket-Protocol", hdr)
        }</span>
        <span class="cov0" title="0">if hdr := resp.Header.Get("Set-Cookie"); hdr != "" </span><span class="cov0" title="0">{
                upgradeHeader.Set("Set-Cookie", hdr)
        }</span>

        // Now upgrade the existing incoming request to a WebSocket connection.
        // Also pass the header that we gathered from the Dial handshake.
        <span class="cov0" title="0">connPub, err := upgrader.Upgrade(rw, req, upgradeHeader)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("websocketproxy: couldn't upgrade %s", err)
                return
        }</span>
        <span class="cov0" title="0">defer connPub.Close()

        errClient := make(chan error, 1)
        errBackend := make(chan error, 1)
        replicateWebsocketConn := func(dst, src *websocket.Conn, errc chan error) </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        msgType, msg, err := src.ReadMessage()
                        if err != nil </span><span class="cov0" title="0">{
                                m := websocket.FormatCloseMessage(websocket.CloseNormalClosure, fmt.Sprintf("%v", err))
                                if e, ok := err.(*websocket.CloseError); ok </span><span class="cov0" title="0">{
                                        if e.Code != websocket.CloseNoStatusReceived </span><span class="cov0" title="0">{
                                                m = websocket.FormatCloseMessage(e.Code, e.Text)
                                        }</span>
                                }
                                <span class="cov0" title="0">errc &lt;- err
                                dst.WriteMessage(websocket.CloseMessage, m)
                                break</span>
                        }
                        <span class="cov0" title="0">err = dst.WriteMessage(msgType, msg)
                        if err != nil </span><span class="cov0" title="0">{
                                errc &lt;- err
                                break</span>
                        }
                }
        }

        <span class="cov0" title="0">go replicateWebsocketConn(connPub, connBackend, errClient)
        go replicateWebsocketConn(connBackend, connPub, errBackend)

        var message string
        select </span>{
        case err = &lt;-errClient:<span class="cov0" title="0">
                message = "websocketproxy: Error when copying from backend to client: %v"</span>
        case err = &lt;-errBackend:<span class="cov0" title="0">
                message = "websocketproxy: Error when copying from client to backend: %v"</span>

        }
        <span class="cov0" title="0">if e, ok := err.(*websocket.CloseError); !ok || e.Code == websocket.CloseAbnormalClosure </span><span class="cov0" title="0">{
                log.Printf(message, err)
        }</span>
}

func copyHeader(dst, src http.Header) <span class="cov0" title="0">{
        for k, vv := range src </span><span class="cov0" title="0">{
                for _, v := range vv </span><span class="cov0" title="0">{
                        dst.Add(k, v)
                }</span>
        }
}

func copyResponse(rw http.ResponseWriter, resp *http.Response) error <span class="cov0" title="0">{
        copyHeader(rw.Header(), resp.Header)
        rw.WriteHeader(resp.StatusCode)
        defer resp.Body.Close()

        _, err := io.Copy(rw, resp.Body)
        return err
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">// routes.go

package main

import (
        "net/http"
        "scaffold/server/api"
        "scaffold/server/auth"
        "scaffold/server/config"
        "scaffold/server/constants"
        "scaffold/server/docs"
        "scaffold/server/manager"
        "scaffold/server/middleware"
        "scaffold/server/page"

        "github.com/gin-gonic/gin"
        swaggerfiles "github.com/swaggo/files"
        ginSwagger "github.com/swaggo/gin-swagger"
)

func initializeRoutes() <span class="cov2" title="2">{
        router.Static("/static/css", "./static/css")
        router.Static("/static/img", "./static/img")
        router.Static("/static/js", "./static/js")

        // Swagger docs
        docs.SwaggerInfo.BasePath = "/api/v1"
        router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerfiles.Handler))

        router.GET("/", page.RedirectIndexPage)

        router.NoRoute(func(c *gin.Context) </span><span class="cov10" title="39">{
                c.HTML(http.StatusNotFound, "/ui/404", gin.H{})
        }</span>)

        <span class="cov2" title="2">healthRoutes := router.Group("/health", middleware.CORSMiddleware())
        </span><span class="cov2" title="2">{
                healthRoutes.GET("/healthy", api.Healthy)
                healthRoutes.GET("/ready", api.Ready)
                if config.Config.Node.Type == constants.NODE_TYPE_WORKER </span><span class="cov1" title="1">{
                        healthRoutes.GET("/available", api.Available)
                }</span> else<span class="cov1" title="1"> {
                        healthRoutes.GET("/status", middleware.EnsureLoggedIn(), manager.GetStatus)
                }</span>
        }

        <span class="cov2" title="2">if config.Config.Node.Type == constants.NODE_TYPE_MANAGER </span><span class="cov1" title="1">{
                authRoutes := router.Group("/auth", middleware.CORSMiddleware())
                </span><span class="cov1" title="1">{
                        authRoutes.POST("/login", middleware.EnsureNotLoggedIn(), auth.PerformLogin)
                        authRoutes.GET("/logout", middleware.EnsureLoggedIn(), auth.PerformLogout)
                        authRoutes.POST("/reset/request", middleware.EnsureNotLoggedIn(), auth.RequestPasswordReset)
                        authRoutes.POST("/reset/do", middleware.EnsureNotLoggedIn(), auth.DoPasswordReset)
                        authRoutes.POST("/join", auth.JoinNode)
                        authRoutes.POST("/token/:username/:name", middleware.EnsureLoggedIn(), middleware.EnsureSelf(), api.GenerateAPIToken)
                        authRoutes.DELETE("/token/:username/:name", middleware.EnsureLoggedIn(), middleware.EnsureSelf(), api.RevokeAPIToken)
                }</span>

                <span class="cov1" title="1">apiRoutes := router.Group("/api", middleware.CORSMiddleware())
                </span><span class="cov1" title="1">{
                        v1Routes := apiRoutes.Group("/v1")
                        </span><span class="cov1" title="1">{
                                cascadeRoutes := v1Routes.Group("/cascade")
                                </span><span class="cov1" title="1">{
                                        cascadeRoutes.GET("", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write", "read"}), api.GetAllCascades)
                                        cascadeRoutes.GET("/:name", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write", "read"}), middleware.EnsureCascadeGroup("name"), api.GetCascadeByName)
                                        cascadeRoutes.DELETE("/:name", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), middleware.EnsureCascadeGroup("name"), api.DeleteCascadeByName)
                                        cascadeRoutes.POST("", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), api.CreateCascade)
                                        cascadeRoutes.PUT("/:name", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), middleware.EnsureCascadeGroup("name"), api.UpdateCascadeByName)
                                }</span>
                                <span class="cov1" title="1">datastoreRoutes := v1Routes.Group("/datastore")
                                </span><span class="cov1" title="1">{
                                        datastoreRoutes.GET("", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write", "read"}), api.GetAllDataStores)
                                        datastoreRoutes.GET("/:name", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write", "read"}), middleware.EnsureCascadeGroup("name"), api.GetDataStoreByCascade)
                                        datastoreRoutes.DELETE("/:name", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), middleware.EnsureCascadeGroup("name"), api.DeleteDataStoreByCascade)
                                        datastoreRoutes.POST("", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), api.CreateDataStore)
                                        datastoreRoutes.PUT("/:name", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), middleware.EnsureCascadeGroup("name"), api.UpdateDataStoreByCascade)
                                        datastoreRoutes.GET("/file/:name/:file", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write", "read"}), middleware.EnsureCascadeGroup("name"), api.DownloadFile)
                                        datastoreRoutes.POST("/file/:name", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write", "read"}), middleware.EnsureCascadeGroup("name"), api.UploadFile)
                                }</span>
                                <span class="cov1" title="1">stateRoutes := v1Routes.Group("/state")
                                </span><span class="cov1" title="1">{
                                        stateRoutes.GET("", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write", "read"}), api.GetAllStates)
                                        stateRoutes.GET("/:cascade", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write", "read"}), middleware.EnsureCascadeGroup("cascade"), api.GetStatesByCascade)
                                        stateRoutes.GET("/:cascade/:task", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write", "read"}), middleware.EnsureCascadeGroup("cascade"), api.GetStateByNames)
                                        stateRoutes.DELETE("/:cascade", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), middleware.EnsureCascadeGroup("cascade"), api.DeleteStatesByCascade)
                                        stateRoutes.DELETE("/:cascade/:task", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), middleware.EnsureCascadeGroup("cascade"), api.DeleteStateByNames)
                                        stateRoutes.POST("", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), api.CreateState)
                                        stateRoutes.PUT("/:cascade/:task", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), middleware.EnsureCascadeGroup("cascade"), api.UpdateStateByNames)
                                }</span>
                                <span class="cov1" title="1">inputRoutes := v1Routes.Group("/input")
                                </span><span class="cov1" title="1">{
                                        inputRoutes.GET("", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write", "read"}), api.GetAllInputs)
                                        inputRoutes.GET("/:cascade", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write", "read"}), middleware.EnsureCascadeGroup("cascade"), api.GetInputsByCascade)
                                        inputRoutes.GET("/:cascade/:name", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write", "read"}), middleware.EnsureCascadeGroup("cascade"), api.GetInputByNames)
                                        inputRoutes.DELETE("/:cascade", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), middleware.EnsureCascadeGroup("cascade"), api.DeleteInputsByCascade)
                                        inputRoutes.DELETE("/:cascade/:name", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), middleware.EnsureCascadeGroup("cascade"), api.DeleteInputByNames)
                                        inputRoutes.POST("", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), api.CreateInput)
                                        inputRoutes.POST("/:cascade/update", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), middleware.EnsureCascadeGroup("cascade"), api.UpdateInputDependenciesByName)
                                        inputRoutes.PUT("/:cascade/:name", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), middleware.EnsureCascadeGroup("cascade"), api.UpdateInputByNames)
                                }</span>
                                <span class="cov1" title="1">taskRoutes := v1Routes.Group("/task")
                                </span><span class="cov1" title="1">{
                                        taskRoutes.GET("", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write", "read"}), api.GetAllTasks)
                                        taskRoutes.GET("/:cascade", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write", "read"}), middleware.EnsureCascadeGroup("cascade"), api.GetTasksByCascade)
                                        taskRoutes.GET("/:cascade/:task", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write", "read"}), middleware.EnsureCascadeGroup("cascade"), api.GetTaskByNames)
                                        taskRoutes.DELETE("/:cascade", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), middleware.EnsureCascadeGroup("cascade"), api.DeleteTasksByCascade)
                                        taskRoutes.DELETE("/:cascade/:task", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), middleware.EnsureCascadeGroup("cascade"), api.DeleteTaskByNames)
                                        taskRoutes.POST("", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), api.CreateTask)
                                        taskRoutes.PUT("/:cascade/:task", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), middleware.EnsureCascadeGroup("cascade"), api.UpdateTaskByNames)
                                }</span>
                                <span class="cov1" title="1">userRoutes := v1Routes.Group("/user")
                                </span><span class="cov1" title="1">{
                                        userRoutes.GET("", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write", "read"}), api.GetAllUsers)
                                        userRoutes.GET("/:username", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write", "read"}), api.GetUserByUsername)
                                        userRoutes.DELETE("/:username", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), api.DeleteUserByUsername)
                                        userRoutes.POST("", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin"}), api.CreateUser)
                                        userRoutes.PUT("/:username", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), api.UpdateUserByUsername)
                                }</span>
                                <span class="cov1" title="1">runRoutes := v1Routes.Group("/run")
                                </span><span class="cov1" title="1">{
                                        runRoutes.POST(":cascade/:task", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), middleware.EnsureCascadeGroup("cascade"), api.CreateRun)
                                        runRoutes.POST(":cascade/:task/check", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), middleware.EnsureCascadeGroup("cascade"), api.CreateCheckRun)
                                        runRoutes.GET("/containers", middleware.EnsureLoggedIn(), api.GetAllContainers)
                                        runRoutes.DELETE("/:cascade/:task/:number", middleware.EnsureLoggedIn(), middleware.EnsureCascadeGroup("cascade"), api.ManagerKillRun)
                                }</span>
                        }
                }

                <span class="cov1" title="1">uiRoutes := router.Group("/ui", middleware.CORSMiddleware())
                </span><span class="cov1" title="1">{
                        uiRoutes.GET("/login", middleware.EnsureNotLoggedIn(), page.ShowLoginPage)
                        uiRoutes.GET("/forgot_password", middleware.EnsureNotLoggedIn(), page.ShowForgotPasswordPage)
                        uiRoutes.GET("/email_success", middleware.EnsureNotLoggedIn(), page.ShowEmailSuccessPage)
                        uiRoutes.GET("/email_failure", middleware.EnsureNotLoggedIn(), page.ShowEmailFailurePage)
                        uiRoutes.GET("/reset_password/:reset_password", middleware.EnsureNotLoggedIn(), page.ShowResetPasswordPage)

                        uiRoutes.GET("/cascades", middleware.EnsureLoggedIn(), page.ShowCascadesPage)
                        uiRoutes.GET("/cascades/:name", middleware.EnsureLoggedIn(), page.ShowCascadePage)

                        uiRoutes.GET("/files", middleware.EnsureLoggedIn(), page.ShowFilesPage)

                        uiRoutes.GET("/users", middleware.EnsureLoggedIn(), page.ShowUsersPage)
                        uiRoutes.GET("/user/:username", middleware.EnsureLoggedIn(), page.ShowUserPage)
                }</span>
        }
        <span class="cov2" title="2">if config.Config.Node.Type == constants.NODE_TYPE_WORKER </span><span class="cov1" title="1">{
                apiRoutes := router.Group("/api", middleware.CORSMiddleware())
                </span><span class="cov1" title="1">{
                        v1Routes := apiRoutes.Group("/v1")
                        </span><span class="cov1" title="1">{
                                v1Routes.POST("/trigger", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), api.TriggerRun)
                                v1Routes.GET("/state/:cascade/:task/:number", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write", "read"}), api.GetRunState)
                                v1Routes.GET("/available", middleware.EnsureLoggedIn(), api.GetAvailableContainers)
                                v1Routes.DELETE("/kill/:cascade/:task/:number", middleware.EnsureLoggedIn(), api.KillRun)
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package run

import (
        "bytes"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "os"
        "os/exec"
        "scaffold/server/constants"
        "scaffold/server/datastore"
        "scaffold/server/filestore"
        "scaffold/server/input"
        "scaffold/server/logger"
        "scaffold/server/state"
        "scaffold/server/task"
        "strings"
        "time"
)

var runError error

// type CheckRun struct {
//         Enabled bool           `json:"enabled"`
//         Name    string         `json:"name"`
//         Task    task.TaskCheck `json:"task"`
//         State   state.State    `json:"state"`
// }

type Run struct {
        Name     string      `json:"name"`
        Task     task.Task   `json:"task"`
        State    state.State `json:"state"`
        Previous state.State `json:"previous"`
        Number   int         `json:"number"`
        Groups   []string    `json:"groups"`
}

func setErrorStatus(r *Run, output string) <span class="cov0" title="0">{
        r.State.Output = output
        r.State.Status = constants.STATE_STATUS_ERROR
        currentTime := time.Now().UTC()
        r.State.Finished = currentTime.Format("2006-01-02T15:04:05Z")
}</span>

func runCmd(cmd *exec.Cmd) <span class="cov0" title="0">{
        runError = cmd.Run()
}</span>

func StartRun(r *Run) (bool, error) <span class="cov0" title="0">{
        r.State.Status = constants.STATE_STATUS_RUNNING
        currentTime := time.Now().UTC()
        r.State.Started = currentTime.Format("2006-01-02T15:04:05Z")

        cName := strings.Split(r.Name, ".")[0]
        logger.Debugf("", "Getting datastore by name %s", cName)
        ds, err := datastore.GetDataStoreByCascade(cName)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Cannot get datastore %s", cName)
                return false, err
        }</span>

        // containerName := strings.Replace(r.Name, ".", "-", -1)
        <span class="cov0" title="0">containerName := fmt.Sprintf("%s-%s-%d", r.State.Cascade, r.State.Task, r.Number)

        runDir := fmt.Sprintf("/tmp/run/%s/%s/%d", r.State.Cascade, r.State.Task, r.Number)
        err = os.MkdirAll(runDir, 0755)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Error creating run directory %s", err.Error())
                setErrorStatus(r, err.Error())
                return false, err
        }</span>

        <span class="cov0" title="0">scriptPath := runDir + "/.run.sh"
        envInPath := runDir + "/.envin"
        displayPath := runDir + "/.display"

        envInput := ""
        for key, val := range r.Task.Inputs </span><span class="cov0" title="0">{
                encoded := base64.StdEncoding.EncodeToString([]byte(ds.Env[val]))
                envInput += fmt.Sprintf("%s;%s\n", key, encoded)
        }</span>
        <span class="cov0" title="0">for _, key := range r.Task.Load.Env </span><span class="cov0" title="0">{
                encoded := base64.StdEncoding.EncodeToString([]byte(ds.Env[key]))
                envInput += fmt.Sprintf("%s;%s\n", key, encoded)
        }</span>
        <span class="cov0" title="0">for key, val := range r.Task.Env </span><span class="cov0" title="0">{
                encoded := base64.StdEncoding.EncodeToString([]byte(val))
                envInput += fmt.Sprintf("%s;%s\n", key, encoded)
        }</span>

        <span class="cov0" title="0">envOutput := ""
        for _, key := range r.Task.Store.Env </span><span class="cov0" title="0">{
                envOutput += fmt.Sprintf("echo \"%s;$(echo \"${%s}\" | base64)\" &gt;&gt; /tmp/run/.envout\n", key, key)
        }</span>

        <span class="cov0" title="0">runScript := fmt.Sprintf(`
        # load ENV var

        while read -r line; do
                name=${line%%;*}
                value=${line#*;}
                export ${name}="$(echo "${value}" | base64 -d)"
        done &lt; /tmp/run/.envin
        
        # run command
        %s
        
        # save ENV vars
        %s
        `, r.Task.Run, envOutput)

        // Write out our run script
        data := []byte(runScript)
        err = os.WriteFile(scriptPath, data, 0777)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Error writing run file %s", err.Error())
                setErrorStatus(r, err.Error())
                return false, err
        }</span>

        // Write out envin script
        <span class="cov0" title="0">data = []byte(envInput)
        err = os.WriteFile(envInPath, data, 0777)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Error writing envin file %s", err.Error())
                setErrorStatus(r, err.Error())
                return false, err
        }</span>

        <span class="cov0" title="0">for _, name := range r.Task.Load.File </span><span class="cov0" title="0">{
                err := filestore.GetFile(fmt.Sprintf("%s/%s", r.Task.Cascade, name), fmt.Sprintf("%s/%s", runDir, name))
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("", "Error getting file %s", err.Error())
                        setErrorStatus(r, err.Error())
                        return false, err
                }</span>
        }

        // Clean up any possible artifacts
        <span class="cov0" title="0">if err := exec.Command("/bin/sh", "-c", fmt.Sprintf("podman kill %s", containerName)).Run(); err != nil </span><span class="cov0" title="0">{
                logger.Infof("", "No running container with name %s exists, skipping kill\n", containerName)
        }</span>
        <span class="cov0" title="0">if err := exec.Command("/bin/sh", "-c", fmt.Sprintf("podman rm %s", containerName)).Run(); err != nil </span><span class="cov0" title="0">{
                logger.Infof("", "No running container with name %s exists, skipping removal\n", containerName)
        }</span>

        <span class="cov0" title="0">podmanCommand := "podman run --privileged -d --security-opt label=disabled --network=host --device /dev/net/tun:/dev/net/tun "

        podmanCommand += fmt.Sprintf("--name %s ", containerName)
        podmanCommand += fmt.Sprintf("--mount type=bind,src=%s,dst=/tmp/run ", runDir)
        for _, m := range r.Task.Load.Mounts </span><span class="cov0" title="0">{
                podmanCommand += fmt.Sprintf("--mount type=bind,src=%s,dst=%s ", m, m)
        }</span>
        <span class="cov0" title="0">for _, e := range r.Task.Load.EnvPassthrough </span><span class="cov0" title="0">{
                podmanCommand += fmt.Sprintf("--env %s=\"${%s}\" ", e, e)
        }</span>
        <span class="cov0" title="0">podmanCommand += r.Task.Image
        podmanCommand += " bash -c /tmp/run/.run.sh"

        logger.Debugf("", "command: %s", podmanCommand)

        cmd := exec.Command("/bin/sh", "-c", podmanCommand)
        var outb, errb bytes.Buffer
        cmd.Stdout = &amp;outb
        cmd.Stderr = &amp;errb
        go runCmd(cmd)

        output, err := exec.Command("/bin/sh", "-c", fmt.Sprintf("podman ps -a --filter \"name=%s\" --format \"{{.Status}}\"", containerName)).CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Encountered error: %v\n", err.Error())
                logger.Debugf("", "STDOUT: %s\n", string(output))

                shouldRestart := false
                if strings.Contains(string(output), "no space left on device") </span><span class="cov0" title="0">{
                        shouldRestart = true
                        logs, err := exec.Command("/bin/sh", "-c", "podman system prune -a -f").CombinedOutput()
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Errorf("", "Prune error string: %s", err.Error())
                        }</span>
                        <span class="cov0" title="0">logger.Debugf("", "Prune output: %s", logs)</span>
                }
                <span class="cov0" title="0">setErrorStatus(r, string(output))
                return shouldRestart, err</span>
        }

        <span class="cov0" title="0">var podmanOutput string
        erroredOut := false
        for !strings.HasPrefix(string(output), "Exited") </span><span class="cov0" title="0">{
                logger.Debugf("", "Checking for exit status: %s", string(output))
                if string(output) == "" </span><span class="cov0" title="0">{
                        podmanOutput = outb.String() + "\n\n" + errb.String()
                        r.State.Output = podmanOutput
                        if runError != nil </span><span class="cov0" title="0">{
                                logger.Errorf("", "Error running pod %s\n", runError.Error())
                                setErrorStatus(r, string(runError.Error()))
                                erroredOut = true
                                break</span>
                        }
                        // Load in display file if present and able
                        <span class="cov0" title="0">if _, err := os.Stat(displayPath); err == nil </span><span class="cov0" title="0">{
                                logger.Tracef("", "Display path is present")
                                data, err := os.ReadFile(displayPath)
                                if err == nil </span><span class="cov0" title="0">{
                                        logger.Tracef("", "Read display file")
                                        var obj []map[string]interface{}
                                        if err := json.Unmarshal(data, &amp;obj); err != nil </span><span class="cov0" title="0">{
                                                logger.Errorf("", "Error unmarshalling display JSON: %v", err)
                                        }</span> else<span class="cov0" title="0"> {
                                                logger.Tracef("", "Updating display object")
                                                r.State.Display = obj
                                        }</span>
                                }
                        }

                } else<span class="cov0" title="0"> {
                        logs, err := exec.Command("/bin/sh", "-c", fmt.Sprintf("podman logs %s", containerName)).CombinedOutput()
                        if err != nil </span><span class="cov0" title="0">{
                                r.State.Output = fmt.Sprintf("%s\n\n--------------------------------\n\n%s--------------------------------\n\n%s", podmanOutput, logs, string(err.Error()))
                        }</span> else<span class="cov0" title="0"> {
                                r.State.Output = fmt.Sprintf("%s\n\n--------------------------------\n\n%s", podmanOutput, string(logs))
                        }</span>
                        // Load in display file if present and able
                        <span class="cov0" title="0">if _, err := os.Stat(displayPath); err == nil </span><span class="cov0" title="0">{
                                logger.Tracef("", "Display path is present")
                                data, err := os.ReadFile(displayPath)
                                if err == nil </span><span class="cov0" title="0">{
                                        logger.Tracef("", "Read display file")
                                        var obj []map[string]interface{}
                                        if err := json.Unmarshal(data, &amp;obj); err != nil </span><span class="cov0" title="0">{
                                                logger.Errorf("", "Error unmarshalling display JSON: %v", err)
                                        }</span> else<span class="cov0" title="0"> {
                                                logger.Tracef("", "Updating display object")
                                                r.State.Display = obj
                                        }</span>
                                }
                        }
                }
                <span class="cov0" title="0">time.Sleep(500 * time.Millisecond)
                output, _ = exec.Command("/bin/sh", "-c", fmt.Sprintf("podman ps -a --filter \"name=%s\" --format \"{{.Status}}\"", containerName)).CombinedOutput()</span>
        }

        <span class="cov0" title="0">if !erroredOut </span><span class="cov0" title="0">{
                openParenIdx := strings.Index(string(output), "(")
                closeParenIdx := strings.Index(string(output), ")")
                returnCode := string(output)[openParenIdx+1 : closeParenIdx]

                logs, err := exec.Command("/bin/sh", "-c", fmt.Sprintf("podman logs %s", containerName)).CombinedOutput()
                if err != nil </span><span class="cov0" title="0">{
                        r.State.Output = fmt.Sprintf("%s\n\n--------------------------------\n\n%s", podmanOutput, string(err.Error()))
                }</span> else<span class="cov0" title="0"> {
                        r.State.Output = fmt.Sprintf("%s\n\n--------------------------------\n\n%s", podmanOutput, string(logs))
                }</span>

                <span class="cov0" title="0">for _, name := range r.Task.Store.File </span><span class="cov0" title="0">{
                        err := filestore.UploadFile(fmt.Sprintf("%s/%s", runDir, name), fmt.Sprintf("%s/%s", r.Task.Cascade, name))
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Errorf("", "ERROR UPLOADING %s: %s\n", fmt.Sprintf("%s/%s", r.Task.Cascade, name), err.Error())
                        }</span>
                        <span class="cov0" title="0">ds.Files = append(ds.Files, name)</span>
                }

                <span class="cov0" title="0">envOutPath := fmt.Sprintf("%s/.envout", runDir)
                var dat []byte
                if _, err := os.Stat(envOutPath); err == nil </span><span class="cov0" title="0">{
                        dat, err = os.ReadFile(envOutPath)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Errorf("", "Error reading file %s\n", err.Error())
                                setErrorStatus(r, err.Error())
                        }</span>
                }
                <span class="cov0" title="0">envVarList := strings.Split(string(dat), "\n")
                envVarMap := map[string]string{}

                for _, val := range envVarList </span><span class="cov0" title="0">{
                        name, val, _ := strings.Cut(val, ";")
                        decoded, _ := base64.StdEncoding.DecodeString(val)
                        envVarMap[name] = string(decoded)
                }</span>

                <span class="cov0" title="0">for _, name := range r.Task.Store.Env </span><span class="cov0" title="0">{
                        ds.Env[name] = envVarMap[name]
                }</span>

                <span class="cov0" title="0">inputs := []input.Input{}
                if err := datastore.UpdateDataStoreByCascade(cName, ds, inputs); err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("", "Error updating datastore %s\n", err.Error())
                        setErrorStatus(r, err.Error())
                }</span>

                <span class="cov0" title="0">currentTime = time.Now().UTC()
                r.State.Finished = currentTime.Format("2006-01-02T15:04:05Z")
                if returnCode == "0" </span><span class="cov0" title="0">{
                        r.State.Status = constants.STATE_STATUS_SUCCESS
                }</span> else<span class="cov0" title="0"> {
                        r.State.Status = constants.STATE_STATUS_ERROR
                }</span>

                <span class="cov0" title="0">if r.Task.ShouldRM </span><span class="cov0" title="0">{
                        rmCommand := fmt.Sprintf("podman rm -f %s", containerName)
                        out, err := exec.Command("bash", "-c", rmCommand).CombinedOutput()
                        logger.Debugf("", "Podman rm: %s", string(out))
                        r.State.Output += fmt.Sprintf("\n\n--------------------------------\n\n%s", string(out))
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error("", err.Error())
                                r.State.Output += fmt.Sprintf("\n\n--------------------------------\n\n%s", err.Error())
                        }</span>
                }
        }
        <span class="cov0" title="0">return false, err</span>
}

func Kill(cn, tn, nn string) error <span class="cov0" title="0">{
        containerName := fmt.Sprintf("%s-%s-%s", cn, tn, nn)
        if err := exec.Command("/bin/sh", "-c", fmt.Sprintf("podman kill %s", containerName)).Run(); err != nil </span><span class="cov0" title="0">{
                logger.Infof("", "No running container with name %s exists, skipping kill\n", containerName)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package state

import (
        "fmt"
        "scaffold/server/constants"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"

        "scaffold/server/mongodb"
)

type State struct {
        Task     string                   `json:"task" bson:"task"`
        Cascade  string                   `json:"cascade" bson:"cascade"`
        Status   string                   `json:"status" bson:"status"`
        Started  string                   `json:"started" bson:"started"`
        Finished string                   `json:"finished" bson:"finished"`
        Output   string                   `json:"output" bson:"output"`
        Display  []map[string]interface{} `json:"display" bson:"display"`
        Number   int                      `json:"number" bson:"number"`
}

func CreateState(s *State) error <span class="cov7" title="98">{
        if _, err := GetStateByNames(s.Cascade, s.Task); err == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("state already exists with names %s, %s", s.Cascade, s.Task)
        }</span>

        <span class="cov7" title="98">_, err := mongodb.Collections[constants.MONGODB_STATE_COLLECTION_NAME].InsertOne(mongodb.Ctx, s)
        return err</span>
}

func DeleteStateByNames(cascade, task string) error <span class="cov1" title="2">{
        filter := bson.M{"cascade": cascade, "task": task}

        collection := mongodb.Collections[constants.MONGODB_STATE_COLLECTION_NAME]
        ctx := mongodb.Ctx

        result, err := collection.DeleteOne(ctx, filter)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="2">if result.DeletedCount != 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("no state found with names %s, %s", cascade, task)
        }</span>

        <span class="cov1" title="2">return nil</span>

}

func DeleteStatesByCascade(cascade string) error <span class="cov2" title="3">{
        filter := bson.M{"cascade": cascade}

        collection := mongodb.Collections[constants.MONGODB_STATE_COLLECTION_NAME]
        ctx := mongodb.Ctx

        result, err := collection.DeleteMany(ctx, filter)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov2" title="3">if result.DeletedCount == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no states found with cascade %s", cascade)
        }</span>

        <span class="cov2" title="3">return nil</span>

}

func GetAllStates() ([]*State, error) <span class="cov4" title="11">{
        filter := bson.D{{}}

        states, err := FilterStates(filter)

        return states, err
}</span>

func GetStateByNames(cascade, task string) (*State, error) <span class="cov8" title="265">{
        filter := bson.M{"cascade": cascade, "task": task}

        states, err := FilterStates(filter)

        if err != nil </span><span class="cov7" title="116">{
                return nil, err
        }</span>

        <span class="cov7" title="149">if len(states) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no state found with names %s, %s", cascade, task)
        }</span>

        <span class="cov7" title="149">if len(states) &gt; 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("multiple states found with names %s, %s", cascade, task)
        }</span>

        <span class="cov7" title="149">return states[0], nil</span>
}

func GetStatesByCascade(cascade string) ([]*State, error) <span class="cov1" title="2">{
        filter := bson.M{"cascade": cascade}

        states, err := FilterStates(filter)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="2">return states, nil</span>
}

func UpdateStateByNames(cascade, task string, s *State) error <span class="cov6" title="48">{
        filter := bson.M{"cascade": cascade, "task": task}

        collection := mongodb.Collections[constants.MONGODB_STATE_COLLECTION_NAME]
        ctx := mongodb.Ctx

        opts := options.Replace().SetUpsert(true)

        result, err := collection.ReplaceOne(ctx, filter, s, opts)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov6" title="48">if result.ModifiedCount != 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("no state found with names %s, %s", cascade, task)
        }</span>

        <span class="cov6" title="48">return nil</span>
}

func FilterStates(filter interface{}) ([]*State, error) <span class="cov8" title="278">{
        // A slice of tasks for storing the decoded documents
        var states []*State

        collection := mongodb.Collections[constants.MONGODB_STATE_COLLECTION_NAME]
        ctx := mongodb.Ctx

        cur, err := collection.Find(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return states, err
        }</span>

        <span class="cov8" title="278">for cur.Next(ctx) </span><span class="cov10" title="797">{
                var s State
                err := cur.Decode(&amp;s)
                if err != nil </span><span class="cov0" title="0">{
                        return states, err
                }</span>

                <span class="cov10" title="797">states = append(states, &amp;s)</span>
        }

        <span class="cov8" title="278">if err := cur.Err(); err != nil </span><span class="cov0" title="0">{
                return states, err
        }</span>

        // once exhausted, close the cursor
        <span class="cov8" title="278">cur.Close(ctx)

        if len(states) == 0 </span><span class="cov7" title="116">{
                return states, mongo.ErrNoDocuments
        }</span>

        <span class="cov7" title="162">return states, nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package task

import (
        "fmt"
        "scaffold/server/constants"
        "scaffold/server/logger"
        "scaffold/server/state"
        "time"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"

        "scaffold/server/mongodb"
)

type TaskDependsOn struct {
        Success []string `json:"success" bson:"success"`
        Error   []string `json:"error" bson:"error"`
        Always  []string `json:"always" bson:"always"`
}

type TaskLoadStore struct {
        Env            []string `json:"env" bson:"env"`
        File           []string `json:"file" bson:"file"`
        EnvPassthrough []string `json:"env_passthrough" bson:"env_passthrough"`
        Mounts         []string `json:"mounts" bson:"mounts"`
}

type TaskCheck struct {
        Interval  int               `json:"interval" bson:"interval"`
        Image     string            `json:"image" bson:"image"`
        Run       string            `json:"run" bson:"run"`
        Store     TaskLoadStore     `json:"store" bson:"store"`
        Load      TaskLoadStore     `json:"load" bson:"load"`
        Env       map[string]string `json:"env" bson:"env"`
        Inputs    map[string]string `json:"inputs" bson:"inputs"`
        Updated   string            `json:"updated" bson:"updated"`
        RunNumber int               `json:"run_number" bson:"run_number"`
}

type Task struct {
        Name        string            `json:"name" bson:"name"`
        Cascade     string            `json:"cascade" bson:"cascade"`
        DependsOn   TaskDependsOn     `json:"depends_on" bson:"depends_on"`
        Image       string            `json:"image" bson:"image"`
        Run         string            `json:"run" bson:"run"`
        Store       TaskLoadStore     `json:"store" bson:"store"`
        Load        TaskLoadStore     `json:"load" bson:"load"`
        Env         map[string]string `json:"env" bson:"env"`
        Inputs      map[string]string `json:"inputs" bson:"inputs"`
        Updated     string            `json:"updated" bson:"updated"`
        Check       TaskCheck         `json:"check" bson:"check"`
        RunNumber   int               `json:"run_number" bson:"run_number"`
        ShouldRM    bool              `json:"should_rm" bson:"should_rm"`
        AutoExecute bool              `json:"auto_execute" bson:"auto_execute"`
}

func CreateTask(t *Task) error <span class="cov6" title="32">{
        if _, err := GetTaskByNames(t.Cascade, t.Name); err == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("task already exists with names %s, %s", t.Cascade, t.Name)
        }</span>

        <span class="cov6" title="32">t.Check.RunNumber = 0

        s := state.State{
                Task:     t.Name,
                Cascade:  t.Cascade,
                Status:   constants.STATE_STATUS_NOT_STARTED,
                Started:  "",
                Finished: "",
                Output:   "",
                Number:   t.RunNumber,
                Display:  make([]map[string]interface{}, 0),
        }
        if err := state.CreateState(&amp;s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov6" title="32">sc := state.State{
                Task:     fmt.Sprintf("SCAFFOLD_CHECK-%s", t.Name),
                Cascade:  t.Cascade,
                Status:   constants.STATE_STATUS_NOT_STARTED,
                Started:  "",
                Finished: "",
                Output:   "",
                Number:   t.RunNumber,
                Display:  make([]map[string]interface{}, 0),
        }
        if err := state.CreateState(&amp;sc); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov6" title="32">sp := state.State{
                Task:     fmt.Sprintf("SCAFFOLD_PREVIOUS-%s", t.Name),
                Cascade:  t.Cascade,
                Status:   constants.STATE_STATUS_NOT_STARTED,
                Started:  "",
                Finished: "",
                Output:   "",
                Number:   0,
                Display:  make([]map[string]interface{}, 0),
        }
        if err := state.CreateState(&amp;sp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov6" title="32">_, err := mongodb.Collections[constants.MONGODB_TASK_COLLECTION_NAME].InsertOne(mongodb.Ctx, t)
        return err</span>
}

func DeleteTaskByNames(cascade, task string) error <span class="cov1" title="1">{
        filter := bson.M{"cascade": cascade, "name": task}

        collection := mongodb.Collections[constants.MONGODB_TASK_COLLECTION_NAME]
        ctx := mongodb.Ctx

        result, err := collection.DeleteOne(ctx, filter)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">if result.DeletedCount != 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("no task found with names %s, %s", cascade, task)
        }</span>

        <span class="cov1" title="1">if err := state.DeleteStateByNames(cascade, task); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>

}

func DeleteTasksByCascade(cascade string) error <span class="cov2" title="2">{
        filter := bson.M{"cascade": cascade}

        collection := mongodb.Collections[constants.MONGODB_TASK_COLLECTION_NAME]
        ctx := mongodb.Ctx

        result, err := collection.DeleteMany(ctx, filter)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov2" title="2">if result.DeletedCount == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no tasks found with cascade %s", cascade)
        }</span>

        <span class="cov2" title="2">if err := state.DeleteStatesByCascade(cascade); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov2" title="2">return nil</span>

}

func GetAllTasks() ([]*Task, error) <span class="cov4" title="11">{
        filter := bson.D{{}}

        tasks, err := FilterTasks(filter)

        return tasks, err
}</span>

func GetTaskByNames(cascade, task string) (*Task, error) <span class="cov7" title="45">{
        filter := bson.M{"cascade": cascade, "name": task}

        tasks, err := FilterTasks(filter)

        if err != nil </span><span class="cov6" title="32">{
                return nil, err
        }</span>

        <span class="cov5" title="13">if len(tasks) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no task found with names %s, %s", cascade, task)
        }</span>

        <span class="cov5" title="13">if len(tasks) &gt; 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("multiple tasks found with names %s, %s", cascade, task)
        }</span>

        <span class="cov5" title="13">return tasks[0], nil</span>
}

func GetTasksByCascade(cascade string) ([]*Task, error) <span class="cov2" title="2">{
        filter := bson.M{"cascade": cascade}

        tasks, err := FilterTasks(filter)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov2" title="2">return tasks, nil</span>
}

func UpdateTaskByNames(cascade, task string, t *Task) error <span class="cov4" title="10">{
        filter := bson.M{"cascade": cascade, "name": task}
        currentTime := time.Now().UTC()
        t.Updated = currentTime.Format("2006-01-02T15:04:05Z")
        t.Cascade = cascade

        logger.Debugf("", "Updating task %v", *t)

        collection := mongodb.Collections[constants.MONGODB_TASK_COLLECTION_NAME]
        ctx := mongodb.Ctx

        opts := options.Replace().SetUpsert(true)

        result, err := collection.ReplaceOne(ctx, filter, t, opts)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="10">if result.ModifiedCount != 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("no task found with names %s, %s", cascade, task)
        }</span>

        <span class="cov4" title="10">logger.Debugf("", "Update result: %v", result)

        return nil</span>
}

func FilterTasks(filter interface{}) ([]*Task, error) <span class="cov7" title="58">{
        // A slice of tasks for storing the decoded documents
        var tasks []*Task

        collection := mongodb.Collections[constants.MONGODB_TASK_COLLECTION_NAME]
        ctx := mongodb.Ctx

        cur, err := collection.Find(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return tasks, err
        }</span>

        <span class="cov7" title="58">for cur.Next(ctx) </span><span class="cov10" title="229">{
                var s Task
                err := cur.Decode(&amp;s)
                if err != nil </span><span class="cov0" title="0">{
                        return tasks, err
                }</span>

                <span class="cov10" title="229">tasks = append(tasks, &amp;s)</span>
        }

        <span class="cov7" title="58">if err := cur.Err(); err != nil </span><span class="cov0" title="0">{
                return tasks, err
        }</span>

        // once exhausted, close the cursor
        <span class="cov7" title="58">cur.Close(ctx)

        if len(tasks) == 0 </span><span class="cov6" title="32">{
                return tasks, mongo.ErrNoDocuments
        }</span>

        <span class="cov6" title="26">return tasks, nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package user

import (
        "fmt"
        "scaffold/server/config"
        "scaffold/server/constants"
        "scaffold/server/utils"
        "time"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
        "golang.org/x/crypto/bcrypt"

        "scaffold/server/mongodb"
)

type User struct {
        Username          string     `json:"username" bson:"username"`
        Password          string     `json:"password" bson:"password"`
        GivenName         string     `json:"given_name" bson:"given_name"`
        FamilyName        string     `json:"family_name" bson:"family_name"`
        Email             string     `json:"email" bson:"email"`
        ResetToken        string     `json:"reset_token" bson:"reset_token"`
        ResetTokenCreated string     `json:"reset_token_created" bson:"reset_token_created"`
        Created           string     `json:"created" bson:"created"`
        Updated           string     `json:"updated" bson:"updated"`
        LoginToken        string     `json:"login_token" bson:"login_token"`
        APITokens         []APIToken `json:"api_tokens" bson:"api_tokens"`
        Groups            []string   `json:"groups" bson:"groups"`
        Roles             []string   `json:"roles" bson:"roles"`
}

type APIToken struct {
        Name    string `json:"name" bson:"name"`
        Token   string `json:"token" bson:"token"`
        Created string `json:"created" bson:"created"`
}

func CreateUser(u *User) error <span class="cov2" title="5">{
        currentTime := time.Now().UTC()
        u.Created = currentTime.Format("2006-01-02T15:04:05Z")
        u.Updated = currentTime.Format("2006-01-02T15:04:05Z")

        if _, err := GetUserByUsername(u.Username); err == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("user already exists with username %s", u.Username)
        }</span>

        <span class="cov2" title="5">password, err := HashAndSalt([]byte(u.Password))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov2" title="5">u.Password = password

        _, err = mongodb.Collections[constants.MONGODB_USER_COLLECTION_NAME].InsertOne(mongodb.Ctx, u)
        return err</span>
}

func DeleteUserByUsername(username string) error <span class="cov0" title="0">{
        filter := bson.M{"username": username}

        collection := mongodb.Collections[constants.MONGODB_USER_COLLECTION_NAME]
        ctx := mongodb.Ctx

        result, err := collection.DeleteOne(ctx, filter)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if result.DeletedCount != 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("no user found with username %s", username)
        }</span>

        <span class="cov0" title="0">return nil</span>

}

func GetAllUsers() ([]*User, error) <span class="cov0" title="0">{
        filter := bson.D{{}}

        users, err := FilterUsers(filter)

        return users, err
}</span>

func GetUserByUsername(username string) (*User, error) <span class="cov4" title="31">{
        filter := bson.M{"username": username}

        users, err := FilterUsers(filter)

        if err != nil </span><span class="cov2" title="6">{
                return nil, err
        }</span>

        <span class="cov4" title="25">if len(users) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no user found with username %s", username)
        }</span>

        <span class="cov4" title="25">if len(users) &gt; 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("multiple users found with username %s", username)
        }</span>

        <span class="cov4" title="25">return users[0], nil</span>
}

func GetUserByAPIToken(apiToken string) (*User, error) <span class="cov8" title="968">{
        // filter := bson.M{"api_tokens": bson.M{"token": apiToken}}

        filter := bson.D{{}}
        users, err := FilterUsers(filter)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="968">for _, u := range users </span><span class="cov9" title="2667">{
                for _, t := range u.APITokens </span><span class="cov9" title="2667">{
                        if err := bcrypt.CompareHashAndPassword([]byte(t.Token), []byte(apiToken)); err == nil </span><span class="cov8" title="968">{
                                return u, nil
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("no user found with api token %s", apiToken)</span>
}

func GetUserByEmail(email string) (*User, error) <span class="cov0" title="0">{
        filter := bson.M{"email": email}

        users, err := FilterUsers(filter)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(users) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no user found with email %s", email)
        }</span>

        <span class="cov0" title="0">if len(users) &gt; 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("multiple users found with email %s", email)
        }</span>

        <span class="cov0" title="0">return users[0], nil</span>
}

func GetUserByLoginToken(loginToken string) (*User, error) <span class="cov4" title="24">{
        /*
                if loginToken == "" {
                        return nil, fmt.Errorf("invalid login token")
                }

                filter := bson.M{"login_token": loginToken}

                users, err := FilterUsers(filter)

                if err != nil {
                        return nil, err
                }

                if len(users) == 0 {
                        return nil, fmt.Errorf("no user found with login token %s", loginToken)
                }

                if len(users) &gt; 1 {
                        return nil, fmt.Errorf("multiple users found with login token %s", loginToken)
                }

                return users[0], nil
        */

        filter := bson.D{{}}
        users, err := FilterUsers(filter)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="24">for _, u := range users </span><span class="cov6" title="120">{
                if err := bcrypt.CompareHashAndPassword([]byte(u.LoginToken), []byte(loginToken)); err == nil </span><span class="cov0" title="0">{
                        return u, nil
                }</span>
        }

        <span class="cov4" title="24">return nil, fmt.Errorf("no user found with login token %s", loginToken)</span>
}

func GetUserByResetToken(resetToken string) (*User, error) <span class="cov0" title="0">{
        /*
                filter := bson.M{"reset_token": resetToken}

                users, err := FilterUsers(filter)

                if err != nil {
                        return nil, err
                }

                if len(users) == 0 {
                        return nil, fmt.Errorf("no user found with reset_token %s", resetToken)
                }

                if len(users) &gt; 1 {
                        return nil, fmt.Errorf("multiple users found with reset_token %s", resetToken)
                }

                return users[0], nil
        */

        filter := bson.D{{}}
        users, err := FilterUsers(filter)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, u := range users </span><span class="cov0" title="0">{
                if err := bcrypt.CompareHashAndPassword([]byte(u.ResetToken), []byte(resetToken)); err == nil </span><span class="cov0" title="0">{
                        return u, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("no user found with reset token %s", resetToken)</span>
}

func GenerateAPIToken(username, name string) (string, error) <span class="cov2" title="5">{
        token := utils.GenerateToken(32)
        currentTime := time.Now().UTC()

        hashedToken, err := HashAndSalt([]byte(token))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov2" title="5">apiToken := APIToken{
                Name:    name,
                Token:   hashedToken,
                Created: currentTime.Format("2006-01-02T15:04:05Z"),
        }

        u, err := GetUserByUsername(username)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov2" title="5">u.APITokens = append(u.APITokens, apiToken)

        err = UpdateUserByUsername(username, u)
        return token, err</span>
}

func RevokeAPIToken(username, name string) error <span class="cov0" title="0">{
        u, err := GetUserByUsername(username)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for idx, apiToken := range u.APITokens </span><span class="cov0" title="0">{
                if apiToken.Name == name </span><span class="cov0" title="0">{
                        u.APITokens = append(u.APITokens[:idx], u.APITokens[idx+1:]...)
                        break</span>
                }
        }

        <span class="cov0" title="0">err = UpdateUserByUsername(username, u)
        return err</span>
}

func UpdateUserByUsername(username string, u *User) error <span class="cov2" title="5">{
        filter := bson.M{"username": username}

        currentTime := time.Now().UTC()
        u.Updated = currentTime.Format("2006-01-02T15:04:05Z")

        collection := mongodb.Collections[constants.MONGODB_USER_COLLECTION_NAME]
        ctx := mongodb.Ctx

        opts := options.Replace().SetUpsert(true)

        result, err := collection.ReplaceOne(ctx, filter, u, opts)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov2" title="5">if result.ModifiedCount != 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("no user found with username %s", username)
        }</span>

        <span class="cov2" title="5">return nil</span>
}

func FilterUsers(filter interface{}) ([]*User, error) <span class="cov8" title="1023">{
        // A slice of tasks for storing the decoded documents
        var users []*User

        collection := mongodb.Collections[constants.MONGODB_USER_COLLECTION_NAME]
        ctx := mongodb.Ctx

        cur, err := collection.Find(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return users, err
        }</span>

        <span class="cov8" title="1023">for cur.Next(ctx) </span><span class="cov10" title="4985">{
                var u User
                err := cur.Decode(&amp;u)
                if err != nil </span><span class="cov0" title="0">{
                        return users, err
                }</span>

                <span class="cov10" title="4985">users = append(users, &amp;u)</span>
        }

        <span class="cov8" title="1023">if err := cur.Err(); err != nil </span><span class="cov0" title="0">{
                return users, err
        }</span>

        // once exhausted, close the cursor
        <span class="cov8" title="1023">cur.Close(ctx)

        if len(users) == 0 </span><span class="cov2" title="6">{
                return users, mongo.ErrNoDocuments
        }</span>

        <span class="cov8" title="1017">return users, nil</span>
}

func VerifyAdmin() error <span class="cov1" title="1">{
        user, _ := GetUserByUsername(config.Config.Admin.Username)

        if user != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov1" title="1">u := &amp;User{
                Username:          config.Config.Admin.Username,
                Password:          config.Config.Admin.Password,
                GivenName:         "admin",
                FamilyName:        "admin",
                Email:             config.Config.Admin.Email,
                ResetToken:        "",
                ResetTokenCreated: "",
                LoginToken:        "",
                APITokens:         []APIToken{},
                Groups:            []string{"admin"},
                Roles:             []string{"admin"},
        }

        err := CreateUser(u)

        return err</span>
}

func HashAndSalt(pwd []byte) (string, error) <span class="cov3" title="10">{
        hash, err := bcrypt.GenerateFromPassword(pwd, bcrypt.MinCost)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov3" title="10">return string(hash), nil</span>
}

func VerifyUser(username, password string) (bool, error) <span class="cov3" title="10">{
        u, err := GetUserByUsername(username)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov3" title="10">err = bcrypt.CompareHashAndPassword([]byte(u.Password), []byte(password))
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov3" title="10">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">// utils.go

package utils

import (
        "log"
        "math/rand"
        "os/exec"
        "scaffold/server/logger"
        "strconv"

        "github.com/gin-gonic/gin"
)

func Error(err error, c *gin.Context, statusCode int) <span class="cov3" title="6">{
        logger.Error("", err.Error())
        c.JSON(statusCode, gin.H{"error": err.Error()})
}</span>

func Contains(s []string, e string) bool <span class="cov10" title="1299">{
        for _, a := range s </span><span class="cov9" title="1081">{
                if a == e </span><span class="cov8" title="435">{
                        return true
                }</span>
        }
        <span class="cov9" title="864">return false</span>
}

func Keys(m map[string]string) []string <span class="cov3" title="6">{
        keys := make([]string, len(m))

        i := 0
        for k := range m </span><span class="cov1" title="2">{
                keys[i] = k
                i++
        }</span>
        <span class="cov3" title="6">return keys</span>
}

func RemoveDuplicateValues(stringSlice []string) []string <span class="cov0" title="0">{
        keys := make(map[string]bool)
        list := []string{}

        // If the key(values of the slice) is not equal
        // to the already present value in new slice (list)
        // then we append it. else we jump on another element.
        for _, entry := range stringSlice </span><span class="cov0" title="0">{
                if _, value := keys[entry]; !value </span><span class="cov0" title="0">{
                        keys[entry] = true
                        list = append(list, entry)
                }</span>
        }
        <span class="cov0" title="0">return list</span>
}

func InstallPackages(packages []string) error <span class="cov0" title="0">{
        out, err := exec.Command("apt-get", "update", "-y").CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("apt-get update: %v", string(out))
                return err
        }</span>
        <span class="cov0" title="0">for _, pkg := range packages </span><span class="cov0" title="0">{
                out, err := exec.Command("apt-get", "install", "-y", pkg).CombinedOutput()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("apt-get install %s: %s", pkg, string(out))
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func GenerateToken(length int) string <span class="cov3" title="5">{
        token := strconv.FormatInt(rand.Int63(), 16) + strconv.FormatInt(rand.Int63(), 16) + strconv.FormatInt(rand.Int63(), 16) + strconv.FormatInt(rand.Int63(), 16) + strconv.FormatInt(rand.Int63(), 16) + strconv.FormatInt(rand.Int63(), 16) + strconv.FormatInt(rand.Int63(), 16) + strconv.FormatInt(rand.Int63(), 16)

        token = token[:length]
        return token
}</span>

func DynamicAPIResponse(ctx *gin.Context, redirect string, status int, response gin.H) <span class="cov0" title="0">{
        _, err := ctx.Cookie("scaffold_token")
        if err == nil </span><span class="cov0" title="0">{
                logger.Debugf("", "Redirecting to %s", redirect)
                ctx.Redirect(302, redirect)
                return
        }</span>
        <span class="cov0" title="0">ctx.JSON(status, response)</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package worker

import (
        "bytes"
        "encoding/json"
        "fmt"
        "net/http"
        "scaffold/server/auth"
        "scaffold/server/cmd"
        "scaffold/server/config"
        "scaffold/server/constants"
        "scaffold/server/container"
        "scaffold/server/filestore"
        "scaffold/server/health"
        "scaffold/server/logger"
        "scaffold/server/mongodb"
        "scaffold/server/run"
        "scaffold/server/state"
        "scaffold/server/task"
        "strings"
        "time"
)

var RunQueue []run.Run

var JoinKey = ""
var PrimaryKey = ""

func Run() <span class="cov1" title="1">{
        mongodb.InitCollections()
        filestore.InitBucket()
        container.CompletedRuns = make(map[string]run.Run)
        StartWebsocketServer()

        health.IsHealthy = true

        JoinKey = config.Config.Node.JoinKey
        PrimaryKey = config.Config.Node.PrimaryKey

        obj := auth.NodeJoinObject{
                Name:     config.Config.Host,
                Host:     config.Config.Host,
                Port:     config.Config.Port,
                WSPort:   config.Config.WSPort,
                Protocol: config.Config.Protocol,
                JoinKey:  JoinKey,
                Version:  constants.VERSION,
        }
        postBody, err := json.Marshal(obj)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov1" title="1">postBodyBuffer := bytes.NewBuffer(postBody)

        httpClient := http.Client{}
        requestURL := fmt.Sprintf("%s://%s:%d/auth/join", config.Config.Node.ManagerProtocol, config.Config.Node.ManagerHost, config.Config.Node.ManagerPort)
        req, _ := http.NewRequest("POST", requestURL, postBodyBuffer)
        req.Header.Set("Content-Type", "application/json")
        resp, err := httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov1" title="1">if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Received join status code %d", resp.StatusCode))</span>
        }

        <span class="cov1" title="1">health.IsReady = true
        health.IsAvailable = true

        go container.PruneContainers()

        PollQueue()</span>
}

func PollQueue() <span class="cov1" title="1">{
        container.InitContainers()
        for </span><span class="cov9" title="3218655581">{
                if !health.IsAvailable </span><span class="cov0" title="0">{
                        time.Sleep(250 * time.Millisecond)
                        continue</span>
                }
                <span class="cov10" title="3218656774">if len(RunQueue) &gt; 0 </span><span class="cov0" title="0">{
                        health.IsAvailable = false
                        container.CurrentRun, RunQueue = RunQueue[0], RunQueue[1:]
                        container.CurrentName = container.CurrentRun.Name
                        shouldRestart, _ := run.StartRun(&amp;container.CurrentRun)
                        if shouldRestart </span><span class="cov0" title="0">{
                                logger.Debugf("", "Should restart is true")
                                RunQueue = append([]run.Run{container.CurrentRun}, RunQueue...)
                        }</span> else<span class="cov0" title="0"> {
                                logger.Debugf("", "Current run name: %s", container.CurrentRun.Name)
                                c := container.CurrentRun
                                t := c.Task
                                s := c.State
                                p := c.Previous
                                container.CompletedRuns[container.CurrentRun.Name] = run.Run{
                                        Name: c.Name,
                                        Task: task.Task{
                                                Name:        t.Name,
                                                Cascade:     t.Cascade,
                                                DependsOn:   t.DependsOn,
                                                Image:       t.Image,
                                                Run:         t.Run,
                                                Store:       t.Store,
                                                Load:        t.Load,
                                                Env:         t.Env,
                                                Inputs:      t.Inputs,
                                                Updated:     t.Updated,
                                                Check:       t.Check,
                                                RunNumber:   t.RunNumber,
                                                AutoExecute: t.AutoExecute,
                                        },
                                        State: state.State{
                                                Task:     s.Task,
                                                Cascade:  s.Cascade,
                                                Status:   s.Status,
                                                Started:  s.Started,
                                                Finished: s.Finished,
                                                Output:   s.Output,
                                                Number:   t.RunNumber,
                                                Display:  s.Display,
                                        },
                                        Previous: state.State{
                                                Task:     p.Task,
                                                Cascade:  p.Cascade,
                                                Status:   p.Status,
                                                Started:  p.Started,
                                                Finished: p.Finished,
                                                Output:   p.Output,
                                                Number:   p.Number,
                                                Display:  p.Display,
                                        },
                                        Number: container.CurrentRun.Number,
                                        Groups: c.Groups,
                                }
                                parts := strings.Split(c.Name, ".")
                                nameParts := strings.Split(parts[1], "-")
                                if !strings.HasSuffix(nameParts[0], "CHECK") </span><span class="cov0" title="0">{
                                        logger.Debugf("", "Adding groups %v to LastGroups", c.Groups)
                                        container.LastRun = append(container.LastRun, container.CurrentRun.Name)
                                        container.LastImage = append(container.LastImage, container.CurrentRun.Task.Image)
                                        container.LastGroups = append(container.LastGroups, c.Groups)
                                }</span>
                        }
                        <span class="cov0" title="0">logger.Debugf("", "current run: %v", container.CurrentRun)
                        container.CurrentRun = run.Run{}
                        health.IsAvailable = true</span>
                }
        }
}

func StartWebsocketServer() <span class="cov1" title="1">{
        logger.Info("", "Starting websocket application")
        //Open a goroutine execution start program
        // go socket.Manager.Start()
        go cmd.StartWSServer()
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
